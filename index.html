<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>RecountPro — пересчет это просто</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="description" content="RecountPro — ускоряет работу в 2–3 раза, избавляет от бумаги и фиктивного пересчёта" />
  <meta name="author" content="Артём Руднев" />
  <link rel="icon" href="favicon.ico" type="image/x-icon" />
  <style>
    :root{
      --bg:#050409;
      --neon:#9b5cff;
      --neon-glow: rgba(155,92,255,0.18);
      --text:#f6f9fb;
      --muted:#b7c4cc;
      --gold:#c79a2a;
      --max-width:980px;
      --radius:16px;
    }

    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter, "Segoe UI", Roboto, system-ui, -apple-system;background:var(--bg);color:var(--text);-webkit-font-smoothing:antialiased}
    a{color:inherit;text-decoration:none}

    /* Fullscreen canvas background */
    .stage{position:fixed;inset:0;z-index:0;overflow:hidden;background:var(--bg)}
    canvas#bgCanvas{display:block;width:100%;height:100%}

    /* Content centered (same plane) */
    .wrap{position:relative;z-index:2;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:28px;pointer-events:none}
    .card{
      width:100%;max-width:var(--max-width);padding:32px;border-radius:18px;
      background: linear-gradient(180deg, rgba(255,255,255,0.018), rgba(255,255,255,0.006));
      border:1px solid rgba(255,255,255,0.03);backdrop-filter:blur(6px) saturate(120%);
      display:flex;flex-direction:column;gap:16px;align-items:center;text-align:center;box-shadow:0 30px 80px rgba(0,0,0,0.6);
      pointer-events:auto;
    }

    /* logo */
    .logo{width:120px;height:120px;border-radius:16px;background:#000;border:4px solid var(--neon);display:flex;align-items:center;justify-content:center;font-weight:900;font-size:56px;color:#000;position:relative;overflow:visible}
    .logo::after{content:"";position:absolute;inset:-8px;border-radius:20px;pointer-events:none;filter:blur(10px);opacity:0.85;background:linear-gradient(90deg, rgba(155,92,255,0.18), rgba(155,92,255,0.08))}
    .headline{font-size:28px;font-weight:800;margin:0;background:linear-gradient(90deg,#ffffff, rgba(155,92,255,0.95));-webkit-background-clip:text;color:transparent;letter-spacing:-0.4px}
    .sub{margin:0;color:var(--muted);font-size:16px;max-width:760px;line-height:1.45}

    /* CTA */
    .actions{display:flex;gap:12px;flex-wrap:wrap;justify-content:center;margin-top:6px}
    .btn{pointer-events:auto;display:inline-flex;align-items:center;justify-content:center;padding:12px 18px;border-radius:12px;font-weight:800;text-decoration:none;border:0;cursor:pointer;transition:transform .18s ease,box-shadow .18s ease}
    .btn-primary{background: linear-gradient(180deg, rgba(155,92,255,0.12), rgba(155,92,255,0.04)); color:var(--text); border:1px solid rgba(155,92,255,0.16); box-shadow:0 12px 36px rgba(155,92,255,0.05)}
    .btn-primary:hover{transform:translateY(-3px);box-shadow:0 28px 80px rgba(155,92,255,0.08)}
    .btn-contact{pointer-events:auto;background:linear-gradient(90deg,#b88728,#d4b65b);color:#070707;padding:12px 20px;border-radius:14px;font-weight:900;border:0;box-shadow:0 18px 60px rgba(200,154,42,0.08)}
    .note{font-size:13px;color:var(--muted)}

    @media (max-width:640px){
      .card{padding:20px;border-radius:14px}
      .logo{width:96px;height:96px;font-size:44px}
      .headline{font-size:20px}
      .sub{font-size:15px}
      .btn{padding:10px 12px}
    }
  </style>
</head>
<body>
  <div class="stage" aria-hidden="true">
    <canvas id="bgCanvas"></canvas>
  </div>

  <div class="wrap" role="main">
    <div class="card" aria-labelledby="headline">
      <div style="display:flex;flex-direction:column;align-items:center;gap:12px;">
        <div class="logo" aria-hidden="true">R</div>
        <h1 id="headline" class="headline">Пересчёт, который возвращает время. Начни экономить в 2–3 раза уже сегодня.</h1>
        <p class="sub">RecountPro убирает бумагу и фиктивный пересчёт: сканируйте, сверяйте, получайте отчёт. Всё — быстро, надёжно и прозрачно. Попробуйте и почувствуйте разницу в первой смене.</p>

        <div class="actions" role="group" aria-label="Действия">
          <a href="login.html" class="btn btn-primary" target="_blank" rel="noopener">WEB Version</a>
          <a href="Scaner.html" class="btn btn-primary" target="_blank" rel="noopener">Скачать приложение</a>
        </div>

        <p class="note">Telegram‑отчёты, PDF‑экспорт, интеграция с 1С и умный ввод. Без бумаги. Без лишних шагов.</p>

        <div style="margin-top:6px">
          <a href="https://t.me/Artem_Rudnev1" class="btn-contact" target="_blank" rel="noopener">Связаться с разработчиком</a>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Canvas: stars + parallax + shimmering twinkle + comet system with long soft tails
    const canvas = document.getElementById('bgCanvas');
    const ctx = canvas.getContext('2d', { alpha: true });
    let W = 0, H = 0, DPR = Math.max(1, window.devicePixelRatio || 1);

    function resize() {
      W = canvas.clientWidth || innerWidth;
      H = canvas.clientHeight || innerHeight;
      canvas.width = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    }
    window.addEventListener('resize', resize);
    resize();

    // utilities
    const rand = (a,b) => Math.random()*(b-a)+a;
    const clamp = (v,a,b) => Math.max(a, Math.min(b, v));

    // stars layers
    let stars = [];
    let starLayerCount = 3;
    function initStars(){
      stars = [];
      const base = Math.floor((W*H)/8000);
      for(let layer=0; layer<starLayerCount; layer++){
        const count = base * (layer+1) * 2;
        const arr = [];
        for(let i=0;i<count;i++){
          arr.push({
            x: Math.random()*W,
            y: Math.random()*H,
            size: Math.random()* (layer===0?1.6: (layer===1?1.1:0.6)) + (layer===0?0.6:0.2),
            baseAlpha: Math.random()*0.7 + 0.15,
            phase: Math.random()*Math.PI*2,
            speed: (layer===0?0.02: (layer===1?0.01:0.004)) * (Math.random()*0.6+0.7),
            layer
          });
        }
        stars.push(...arr);
      }
    }

    // comets (long soft tails)
    let comets = [];
    function spawnComet(){
      // entry from random edge, prefer top-left to bottom-right motion
      const fromLeft = Math.random() < 0.6;
      const y = rand(H*0.05, H*0.6);
      const x = fromLeft ? -rand(100, 300) : W + rand(100,300);
      const vx = fromLeft ? rand(3.8, 10.0) : -rand(3.8, 10.0);
      const vy = rand(-0.6, 1.8);
      const speed = Math.hypot(vx, vy);
      const hue = rand(250, 300); // purple-blue
      const tailLen = rand(Math.max(W,H)*0.35, Math.max(W,H)*0.9);
      comets.push({
        x, y, vx, vy, speed, life:0, ttl: rand(3.5, 7.5), alpha: rand(0.6, 1.0),
        tailLen, hue, size: rand(1.8, 3.8)
      });
      // keep limit
      if(comets.length > 5) comets.shift();
    }

    // subtle nebula glow elements for depth
    let blobs = [];
    function initBlobs(){
      blobs = [];
      const zones = [
        {x: W*0.15, y: H*0.18, r: Math.max(W,H)*0.45, hue: 270},
        {x: W*0.82, y: H*0.82, r: Math.max(W,H)*0.55, hue: 210}
      ];
      zones.forEach(z=>{
        for(let i=0;i<18;i++){
          blobs.push({
            x: z.x + rand(-z.r*0.45, z.r*0.45),
            y: z.y + rand(-z.r*0.45, z.r*0.45),
            r: rand(z.r*0.06, z.r*0.32),
            hue: z.hue + rand(-20,20),
            alpha: rand(0.03, 0.18),
            vx: rand(-0.02,0.02),
            vy: rand(-0.01,0.01),
            phase: Math.random()*Math.PI*2
          });
        }
      });
    }

    // parallax via pointer
    const pointer = {x: W/2, y: H/2, tx: W/2, ty: H/2};
    window.addEventListener('mousemove', (e)=>{ pointer.tx = e.clientX; pointer.ty = e.clientY; });
    window.addEventListener('touchmove', (e)=>{ if(e.touches[0]){ pointer.tx = e.touches[0].clientX; pointer.ty = e.touches[0].clientY; } }, {passive:true});

    // draw helpers
    function drawBlobs(dt){
      ctx.globalCompositeOperation = 'lighter';
      blobs.forEach(b=>{
        b.x += b.vx * dt * 60;
        b.y += b.vy * dt * 60;
        b.phase += dt * 0.6;
        const r = b.r;
        const g = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, r);
        g.addColorStop(0, `hsla(${b.hue},85%,60%,${b.alpha})`);
        g.addColorStop(0.5, `hsla(${b.hue+18},75%,52%,${b.alpha*0.6})`);
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.ellipse(b.x + Math.sin(b.phase*0.6)*8, b.y + Math.cos(b.phase*0.7)*6, r, r*0.6, 0, 0, Math.PI*2);
        ctx.fill();
      });
    }

    function drawStars(now){
      ctx.globalCompositeOperation = 'screen';
      for(let i=0;i<stars.length;i++){
        const s = stars[i];
        s.phase += s.speed * 0.6;
        const tw = Math.sin(s.phase*1.6)*0.25 + 0.9;
        const x = s.x + (pointer.x - W/2) * (s.layer*0.002) * tw;
        const y = s.y + (pointer.y - H/2) * (s.layer*0.002) * tw;
        const alpha = clamp(s.baseAlpha * (0.6 + 0.4*tw), 0.03, 1);
        ctx.fillStyle = `rgba(255,255,255,${alpha})`;
        ctx.beginPath();
        ctx.arc(x, y, s.size * (1 + 0.25*tw), 0, Math.PI*2);
        ctx.fill();
      }
    }

    function drawComets(dt){
      ctx.globalCompositeOperation = 'lighter';
      for(let i=comets.length-1;i>=0;i--){
        const c = comets[i];
        c.life += dt;
        const pcount = Math.min(80, Math.floor(c.tailLen/6));
        // head
        ctx.beginPath();
        const headAlpha = c.alpha * (1 - (c.life / c.ttl)*0.6);
        ctx.fillStyle = `rgba(255,255,255,${headAlpha})`;
        ctx.arc(c.x, c.y, c.size*1.6, 0, Math.PI*2);
        ctx.fill();

        // tail - draw back along velocity vector with fading segments
        const angle = Math.atan2(c.vy, c.vx);
        const cos = Math.cos(angle), sin = Math.sin(angle);
        for(let t=0;t<pcount;t++){
          const frac = t / pcount;
          const tx = c.x - cos * frac * c.tailLen;
          const ty = c.y - sin * frac * c.tailLen;
          const tailW = Math.max(0.6, c.size * (1 - frac) * 6);
          const tailAlpha = headAlpha * (1 - frac) * 0.9;
          const grd = ctx.createRadialGradient(tx, ty, 0, tx, ty, tailW*5);
          // purple-blue gradient inside tail
          grd.addColorStop(0, `hsla(${c.hue},90%,65%,${tailAlpha})`);
          grd.addColorStop(0.5, `hsla(${c.hue+18},80%,55%,${tailAlpha*0.45})`);
          grd.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = grd;
          ctx.beginPath();
          ctx.ellipse(tx, ty, tailW*2, tailW, 0, 0, Math.PI*2);
          ctx.fill();
        }

        // motion
        c.x += c.vx * dt * 60;
        c.y += c.vy * dt * 60;

        // fade and remove
        if(c.life > c.ttl || c.x < -c.tailLen*1.2 || c.x > W + c.tailLen*1.2 || c.y < -200 || c.y > H + 200){
          comets.splice(i,1);
        }
      }
    }

    // frame loop
    let last = performance.now();
    function frame(now){
      const dt = Math.min(60, now - last) / 1000; last = now;
      // smooth pointer
      pointer.x += (pointer.tx - pointer.x) * 0.06;
      pointer.y += (pointer.ty - pointer.y) * 0.06;

      // clear with slight alpha for motion blur trail effect
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = 'rgba(3,4,8,0.22)'; // larger alpha -> longer trails
      ctx.fillRect(0,0,W,H);

      // subtle moving nebula blobs
      drawBlobs(dt);

      // stars on top
      drawStars(now);

      // comets and tails
      drawComets(dt);

      // soft vignette
      ctx.globalCompositeOperation = 'source-over';
      const vign = ctx.createRadialGradient(W/2, H/2, Math.min(W,H)/2, W/2, H/2, Math.max(W,H));
      vign.addColorStop(0.0, 'rgba(0,0,0,0)');
      vign.addColorStop(0.6, 'rgba(0,0,0,0.06)');
      vign.addColorStop(1.0, 'rgba(0,0,0,0.42)');
      ctx.fillStyle = vign;
      ctx.fillRect(0,0,W,H);

      requestAnimationFrame(frame);
    }

    // initialization
    function initAll(){
      resize();
      initStars();
      initBlobs();
      comets = [];
      // spawn occasional comets
      if(window._cometInterval) clearInterval(window._cometInterval);
      window._cometInterval = setInterval(()=>{
        if(Math.random() < 0.8) spawnComet();
      }, 2200 + Math.random()*3000);
      last = performance.now();
      requestAnimationFrame(frame);
    }

    // responsive recalculation
    let rtid;
    window.addEventListener('resize', ()=>{ clearTimeout(rtid); rtid = setTimeout(()=>{ initAll(); }, 220); });

    initAll();

    // initial extra spawns for richer start
    for(let i=0;i<3;i++) setTimeout(()=>spawnComet(), 400*i);
  </script>
</body>
</html>
