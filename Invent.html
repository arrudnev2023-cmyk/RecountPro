<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>RecountPro ‚Äî –ü–µ—Ä–µ—Å—á—ë—Ç</title>

  <!-- ZXing -->
  <script src="https://unpkg.com/@zxing/library@latest"></script>

  <style>
    :root{
      --accent:#6d28d9;
      --accent-light:#a78bfa;
      --bg:#000;
      --card:#111;
      --muted:#9aa3b2;
      --text:#e6eef8;
      --radius:12px;
      --maxw:980px;
      --card-bg: linear-gradient(135deg,#1e1e2f,#2a2a40);
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#05030a,#0b0710);color:var(--text);font-family:Inter,Segoe UI,system-ui,Arial;overflow:hidden; touch-action: manipulation;}
    /* prevent double-tap zoom */
    html,body,button,input,select,textarea{ -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; }
    #bg{position:fixed;inset:0;z-index:-1;background:#000}
    header{position:fixed;left:0;right:0;top:0;padding:12px;background:rgba(10,10,12,0.7);backdrop-filter:blur(8px);z-index:1000;border-radius:0 0 14px 14px}
    header h1{margin:0;text-align:center;font-size:1.15rem}
    #search-wrap{max-width:var(--maxw);margin:10px auto;position:relative}
    #search{width:100%;padding:10px 56px 10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:rgba(20,20,24,0.6);color:var(--text);font-size:15px}
    #scan-btn{position:absolute;right:44px;top:50%;transform:translateY(-50%);background:none;border:none;color:var(--muted);cursor:pointer}
    #clear-search{position:absolute;right:8px;top:50%;transform:translateY(-50%);background:none;border:none;color:var(--muted);cursor:pointer}
    #content{position:fixed;left:0;right:0;top:96px;bottom:0;overflow:auto;padding:12px;box-sizing:border-box}
    .card{max-width:var(--maxw);margin:10px auto;padding:12px;border-radius:12px;background:linear-gradient(135deg,#121018,#1b1724);box-shadow:0 10px 30px rgba(0,0,0,0.6)}
    .preview-wrap{border-radius:10px;overflow:hidden;background:#000;border:1px solid rgba(255,255,255,0.03)}
    .preview-wrap.camera-1-3{height:34vh;min-height:140px}
    video#preview{width:100%;height:100%;object-fit:cover;display:block}
    .controls{display:flex;gap:8px;align-items:center;margin-top:10px}
    .btn{padding:8px 10px;border-radius:8px;border:none;cursor:pointer;background:#222;color:var(--text)}
    .btn.primary{background:linear-gradient(90deg,var(--accent),var(--accent-light));color:#07060b;font-weight:700}
    .list{max-width:var(--maxw);margin:12px auto;display:flex;flex-direction:column;gap:8px}

    /* === Card design restored to original but full width === */
    .item{
      width:100%;
      margin:10px 0;
      padding:12px;
      border-radius:12px;
      background:var(--card-bg);
      box-shadow:0 8px 30px rgba(0,0,0,0.6);
      border-left:6px solid transparent;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .item.match{border-left-color:#22c55e}
    .item.missing{border-left-color:#ef4444}
    .item.excess{border-left-color:#3b82f6}
    .item.found{box-shadow:0 18px 50px rgba(106,17,203,0.18);transform:translateY(-6px)}
    .field{margin-bottom:8px}
    .label{font-weight:700;color:#dbeafe;margin-right:6px}
    input[data-code]{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:#fff;color:#000;font-size:15px}

    /* keyboard */
    #custom-keyboard{position:fixed;left:0;right:0;bottom:-40vh;height:34vh;background:#0b0b0d;padding:10px;display:grid;grid-template-columns:repeat(3,1fr);gap:8px;z-index:3000;transition:bottom .28s}
    #custom-keyboard.show{bottom:0}
    #custom-keyboard button{border:none;border-radius:8px;background:#222;color:#fff;font-size:20px;cursor:pointer}
    .hidden{display:none!important}
    @media(min-width:900px){#content{padding-left:24px;padding-right:24px}}
  </style>
</head>
<body>
  <canvas id="bg"></canvas>

  <header>
    <h1>RecountPro ‚Äî –ü–µ—Ä–µ—Å—á—ë—Ç</h1>
    <div id="search-wrap">
      <input id="search" placeholder="–ü–æ–∏—Å–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –∏–ª–∏ –∫–æ–¥—É..." autocomplete="off" />
      <button id="scan-btn" title="–û—Ç–∫—Ä—ã—Ç—å —Å–∫–∞–Ω–µ—Ä">üì∑</button>
      <button id="clear-search" title="–û—á–∏—Å—Ç–∏—Ç—å">√ó</button>
    </div>
  </header>

  <main id="content">
    <!-- Scanner card -->
    <div class="card" id="scannerCard" style="display:none">
      <div class="preview-wrap camera-1-3" id="previewWrap"><video id="preview" playsinline muted></video></div>
      <div class="controls">
        <select id="deviceSelect" class="btn" style="min-width:160px"></select>
        <button id="torchBtn" class="btn">üî¶</button>
        <button id="closeScannerBtn" class="btn">–ó–∞–∫—Ä—ã—Ç—å</button>
        <div id="scanResult" style="margin-left:auto;color:var(--muted)"></div>
      </div>
    </div>

    <!-- Items list -->
    <div id="list" class="list"></div>
  </main>

  <!-- Custom keyboard -->
  <div id="custom-keyboard" aria-hidden="true">
    <button>1</button><button>2</button><button>3</button>
    <button>4</button><button>5</button><button>6</button>
    <button>7</button><button>8</button><button>9</button>
    <button>+</button><button>0</button><button id="back">‚Üê</button>
    <button class="done" id="done" style="grid-column:1 / -1">–ì–æ—Ç–æ–≤–æ</button>
  </div>

<script>
/* =========================
   State and elements
   ========================= */
let db = JSON.parse(localStorage.getItem('barcodeDB') || '{}'); // real DB from Scaner.html
let barcodeDB = db; // alias
let allItems = [];
let sessionValues = {};
let activeInput = null;

/* Scanner state */
let stream = null;
let currentDeviceId = null;
let scanning = false;
let detector = ('BarcodeDetector' in window) ? new BarcodeDetector({formats: ["ean_13","ean_8","code_128","code_39","upc_a","upc_e","itf"]}) : null;
let reader = null; // ZXing reader instance
let lastDetected = {code:null, ts:0};
const DEBOUNCE_MS = 900;

/* Canvas pool for decoding */
let canvasPool = [];
let scanLoopRunning = false;

/* Elements */
const listEl = document.getElementById('list');
const searchEl = document.getElementById('search');
const scanBtn = document.getElementById('scan-btn');
const clearSearchBtn = document.getElementById('clear-search');

const scannerCard = document.getElementById('scannerCard');
const preview = document.getElementById('preview');
const previewWrap = document.getElementById('previewWrap');
const deviceSelect = document.getElementById('deviceSelect');
const closeScannerBtn = document.getElementById('closeScannerBtn');
const torchBtn = document.getElementById('torchBtn');
const scanResult = document.getElementById('scanResult');

const keyboard = document.getElementById('custom-keyboard');

/* =========================
   Utilities
   ========================= */
function showToast(text, ms = 1200){
  scanResult.innerText = text;
  setTimeout(()=>{ if(scanResult.innerText === text) scanResult.innerText = ''; }, ms);
}
function saveDB(){ localStorage.setItem('barcodeDB', JSON.stringify(barcodeDB)); }
function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }

/* =========================
   Load DB and build items
   ========================= */
function loadBarcodeDB(){
  try{
    const raw = localStorage.getItem('barcodeDB');
    if(raw){
      const parsed = JSON.parse(raw);
      if(parsed && typeof parsed === 'object'){
        barcodeDB = parsed;
        db = barcodeDB;
        return;
      }
    }
  }catch(e){}
  // fallback sample if none
  barcodeDB = {
    "4601234000011": { code: "4601234000011", name: "–ú–æ–ª–æ–∫–æ 1–ª", unit: "—à—Ç", price: 59.90 },
    "4601234000028": { code: "4601234000028", name: "–•–ª–µ–± —Ä–∂–∞–Ω–æ–π", unit: "—à—Ç", price: 35.00 },
    "4601234000035": { code: "4601234000035", name: "–Ø–±–ª–æ–∫–∏ –∫–≥", unit: "–∫–≥", price: 120.00 },
    "4601234000042": { code: "4601234000042", name: "–°—ã—Ä 200–≥", unit: "—à—Ç", price: 250.00 },
    "4601234000059": { code: "4601234000059", name: "–ö–æ—Ñ–µ 250–≥", unit: "—à—Ç", price: 499.00 }
  };
  db = barcodeDB;
  saveDB();
}

function buildAllItemsFromDB(){
  allItems = Object.keys(barcodeDB).map(k=>{
    const b = barcodeDB[k];
    return { code: b.code, name: b.name, unit: b.unit || '', price: b.price || 0, docQty: 0 };
  });
}

/* =========================
   Render UI (title first, then barcode)
   ========================= */
function render(items){
  listEl.innerHTML = '';
  items.forEach(item=>{
    const value = sessionValues[item.code] || localStorage.getItem('qty_' + item.code) || '';
    const div = document.createElement('div');
    div.className = 'item';
    div.dataset.code = item.code;
    // Title first, then barcode (user requested)
    div.innerHTML = `
      <div class="field"><span class="label">–ù–∞–∑–≤–∞–Ω–∏–µ:</span> ${escapeHtml(item.name)}</div>
      <div class="field"><span class="label">–ê—Ä—Ç–∏–∫—É–ª:</span> ${item.code}</div>
      <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
        <div style="flex:1">
          <input type="text" data-code="${item.code}" value="${escapeHtml(value)}" inputmode="none" readonly />
        </div>
        <div style="min-width:70px;text-align:right;color:var(--muted)">${item.docQty} —à—Ç</div>
      </div>
    `;
    // initial coloring
    let actual = 0;
    try{ actual = Function("return " + (value || "0").replace(',', '.'))() || 0; }catch{}
    if(actual === item.docQty) div.classList.add('match');
    else if(actual < item.docQty) div.classList.add('missing');
    else if(actual > item.docQty) div.classList.add('excess');

    listEl.appendChild(div);
  });
  attachInputHandlers();
}

/* =========================
   Keyboard & input handlers
   - Back button removes one Unicode code point (one character)
   - Ensure back button is handled only once
   ========================= */
function removeLastCodePoint(str){
  if(!str) return '';
  const arr = Array.from(str);
  arr.pop();
  return arr.join('');
}

function attachInputHandlers(){
  document.querySelectorAll('input[data-code]').forEach(input=>{
    input.addEventListener('focus', ()=> openKeyboardFor(input));
    input.addEventListener('click', ()=> openKeyboardFor(input));
  });

  // Attach handlers for keyboard buttons except back/done which are handled separately
  keyboard.querySelectorAll('button').forEach(btn=>{
    const id = btn.id || '';
    if(id === 'back' || id === 'done') return; // skip, will attach separately
    btn.onclick = ()=>{
      if(!activeInput) return;
      const v = btn.textContent;
      activeInput.value += v;
      activeInput.dispatchEvent(new Event('input',{bubbles:true}));
    };
  });

  // Back button: single handler that removes one code point
  const backBtn = document.getElementById('back');
  if(backBtn){
    backBtn.onclick = ()=>{
      if(!activeInput) return;
      activeInput.value = removeLastCodePoint(activeInput.value);
      activeInput.dispatchEvent(new Event('input',{bubbles:true}));
    };
  }

  // Done button
  const doneBtn = document.getElementById('done');
  if(doneBtn) doneBtn.onclick = closeKeyboard;

  // Close keyboard when clicking outside
  document.addEventListener('click', e=>{
    if(!e.target.closest('#custom-keyboard') && !e.target.matches('input[data-code]')) closeKeyboard();
  });
}

function openKeyboardFor(input){
  activeInput = input;
  keyboard.classList.add('show');
  document.getElementById('content').classList.add('with-keyboard');
  setTimeout(()=>{
    const rect = input.getBoundingClientRect();
    const viewportH = window.innerHeight;
    const padHeight = Math.max(260, Math.round(viewportH * 0.34));
    const desiredBottom = padHeight + 12;
    if(rect.bottom > viewportH - desiredBottom){
      const content = document.getElementById('content');
      const offset = rect.bottom - (viewportH - desiredBottom);
      content.scrollBy({ top: offset + 12, behavior: 'smooth' });
    } else {
      input.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  },150);
}

function closeKeyboard(){
  activeInput = null;
  keyboard.classList.remove('show');
  document.getElementById('content').classList.remove('with-keyboard');
}

/* handle manual input changes */
listEl.addEventListener('input', e=>{
  if(e.target.tagName !== 'INPUT') return;
  const code = e.target.dataset.code;
  const value = e.target.value;
  sessionValues[code] = value;
  localStorage.setItem('qty_' + code, value);

  const raw = value.replace(',', '.').trim();
  let actual = NaN;
  try{
    let safeRaw = raw;
    if(/[\+\-\*\/]$/.test(safeRaw)) safeRaw = safeRaw.slice(0,-1);
    if(safeRaw) actual = Function('return ' + safeRaw)();
  }catch{ actual = NaN; }

  const item = allItems.find(i=>i.code === code);
  const card = e.target.closest('.item');
  card.classList.remove('match','missing','excess');
  if(!value) {}
  else if(!isNaN(actual)){
    if(actual === item.docQty) card.classList.add('match');
    else if(actual < item.docQty) card.classList.add('missing');
    else if(actual > item.docQty) card.classList.add('excess');
  }
  autosave();
});

/* =========================
   Search: hide non-matching cards
   ========================= */
function normalize(s){ return String(s||'').toLowerCase().replace(/—ë/g,'–µ').replace(/\s+/g,' ').trim(); }
function matchesQuery(text, query){ const words = query.split(' ').filter(Boolean); return words.every(w => text.includes(w)); }

searchEl.addEventListener('input', ()=>{
  const q = normalize(searchEl.value);
  document.querySelectorAll('#list .item').forEach(div=>{
    const code = normalize(div.dataset.code);
    const item = allItems.find(i=>i.code === div.dataset.code);
    if(!item){ div.classList.add('hidden'); return; }
    const name = normalize(item.name);
    const match = (q === '') || matchesQuery(name, q) || matchesQuery(code, q);
    div.classList.toggle('hidden', !match);
  });
});
clearSearchBtn.addEventListener('click', ()=>{ searchEl.value=''; document.querySelectorAll('#list .item').forEach(d=>d.classList.remove('hidden')); });

/* =========================
   Autosave
   ========================= */
function autosave(){
  const currentLocalkaId = (window.localkaData && window.localkaData.docId) ? window.localkaData.docId : 'loc_' + new Date().toISOString().slice(0,10);
  const sessionKey = 'autosave_session_' + currentLocalkaId;
  const session = { items: allItems, values: sessionValues };
  localStorage.setItem(sessionKey, JSON.stringify(session));
}
window.addEventListener('beforeunload', autosave);

/* =========================
   Camera helpers (from your Scaner.html)
   ========================= */
async function enumerateCameras(){
  try{
    const devices = await navigator.mediaDevices.enumerateDevices();
    const cams = devices.filter(d => d.kind === 'videoinput');
    deviceSelect.innerHTML = '';
    cams.forEach((c, idx)=>{
      const opt = document.createElement('option');
      opt.value = c.deviceId;
      opt.text = c.label || `–ö–∞–º–µ—Ä–∞ ${idx+1}`;
      deviceSelect.appendChild(opt);
    });
    if(cams.length && !currentDeviceId) currentDeviceId = cams[0].deviceId;
    if(currentDeviceId) deviceSelect.value = currentDeviceId;
  }catch(e){}
}

/* startCamera / stopCamera and scanning loop (adapted) */
async function startCamera(){
  if(scanning) return;
  stopCamera();
  scanning = true;
  await enumerateCameras();

  const constraints = {
    audio:false,
    video:{
      deviceId: deviceSelect.value || currentDeviceId || undefined,
      facingMode: { ideal: "environment" },
      width: { ideal: 1280 },
      height: { ideal: 720 }
    }
  };

  try{
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    preview.srcObject = stream;
    await preview.play();
    currentDeviceId = stream.getVideoTracks()[0].getSettings().deviceId || currentDeviceId;
    if(currentDeviceId) deviceSelect.value = currentDeviceId;

    if(!reader) reader = new ZXing.BrowserMultiFormatReader();

    requestAnimationFrame(scanLoop);
    scannerCard.style.display = 'block';
    showToast('–°–∫–∞–Ω–µ—Ä –≤–∫–ª—é—á—ë–Ω');
  }catch(err){
    console.error('camera error', err);
    scanResult.innerText = '–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ';
    scanning = false;
    showToast('–ù–µ —É–¥–∞–ª–æ—Å—å –≤–∫–ª—é—á–∏—Ç—å –∫–∞–º–µ—Ä—É');
  }
}

function stopCamera(){
  scanning = false;
  if(preview.srcObject){
    try{ preview.srcObject.getTracks().forEach(t=>t.stop()); }catch(e){}
    preview.srcObject = null;
  }
  if(reader){
    try{ reader.reset(); }catch(e){}
  }
  scannerCard.style.display = 'none';
  showToast('–°–∫–∞–Ω–µ—Ä –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω');
}

/* Torch toggle */
let torchOn = false;
async function toggleTorch(){
  if(!stream) return showToast('–°–Ω–∞—á–∞–ª–∞ –≤–∫–ª—é—á–∏—Ç–µ —Å–∫–∞–Ω–µ—Ä');
  const track = stream.getVideoTracks()[0];
  try{
    await track.applyConstraints({ advanced: [{ torch: !torchOn }] });
    torchOn = !torchOn;
    torchBtn.textContent = torchOn ? 'üî¶ ON' : 'üî¶';
  }catch(e){
    showToast('Torch –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è');
  }
}

/* Canvas helpers for decoding */
function createCanvas(w,h){ const c=document.createElement('canvas'); c.width=w; c.height=h; return c; }
function getCanvas(w,h){
  for(let c of canvasPool) if(c.width===w && c.height===h) return c;
  const c = createCanvas(w,h); canvasPool.push(c); return c;
}

/* tryDecodeCanvas uses BarcodeDetector if available, otherwise ZXing */
async function tryDecodeCanvas(canvas){
  if(detector){
    try{
      const imageData = canvas.getContext('2d').getImageData(0,0,canvas.width,canvas.height);
      const res = await detector.detect(imageData);
      if(res && res.length) return res[0].rawValue;
    }catch(e){}
  }
  try{
    const luminanceSource = new ZXing.HTMLCanvasElementLuminanceSource(canvas);
    const binaryBitmap = new ZXing.BinaryBitmap(new ZXing.HybridBinarizer(luminanceSource));
    const result = new ZXing.MultiFormatReader().decode(binaryBitmap);
    if(result && result.text) return result.text;
  }catch(e){}
  // try rotated variants
  const w = canvas.width, h = canvas.height;
  const temp = getCanvas(w,h);
  const tctx = temp.getContext('2d');
  for(let angle of [90,180,270]){
    tctx.clearRect(0,0,w,h);
    tctx.save();
    tctx.translate(w/2,h/2);
    tctx.rotate(angle*Math.PI/180);
    tctx.drawImage(canvas, -w/2, -h/2);
    tctx.restore();
    try{
      const luminanceSource = new ZXing.HTMLCanvasElementLuminanceSource(temp);
      const binaryBitmap = new ZXing.BinaryBitmap(new ZXing.HybridBinarizer(luminanceSource));
      const result = new ZXing.MultiFormatReader().decode(binaryBitmap);
      if(result && result.text) return result.text;
    }catch(e){}
  }
  return null;
}

/* Main scanning loop */
async function scanLoop(){
  if(!scanning) { scanLoopRunning = false; return; }
  if(scanLoopRunning) return;
  scanLoopRunning = true;

  try{
    while(scanning){
      const w = preview.videoWidth;
      const h = preview.videoHeight;
      if(w===0 || h===0){
        await new Promise(r => requestAnimationFrame(r));
        continue;
      }

      const canvas = getCanvas(w,h);
      const ctx = canvas.getContext('2d');
      ctx.drawImage(preview, 0, 0, w, h);

      const scale = Math.max(1, Math.floor(Math.max(w,h)/900));
      const sw = Math.floor(w/scale);
      const sh = Math.floor(h/scale);
      const small = getCanvas(sw,sh);
      const sctx = small.getContext('2d');
      sctx.drawImage(canvas, 0, 0, w, h, 0, 0, sw, sh);

      try{
        const code = await tryDecodeCanvas(small);
        if(code) {
          handleDetected(code);
          // small delay to avoid immediate re-detection
          await new Promise(r => setTimeout(r, 300));
        }
      }catch(e){}

      await new Promise(r => requestAnimationFrame(r));
    }
  }finally{
    scanLoopRunning = false;
  }
}

/* Handle detection: stop scanner, show item or prompt to create */
function handleDetected(code){
  const now = Date.now();
  if(code === lastDetected.code && (now - lastDetected.ts) < DEBOUNCE_MS) return;
  lastDetected = {code, ts: now};
  try{ navigator.vibrate?.(60); }catch(e){}
  scanResult.innerText = `${code} ‚Üí ${db[code] || '–¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω'}`;
  // auto-stop scanner
  try{ if(reader) reader.reset(); }catch(e){}
  scanning = false;
  try{ if(preview.srcObject) preview.srcObject.getTracks().forEach(t=>t.stop()); }catch(e){}
  preview.srcObject = null;
  scannerCard.style.display = 'none';

  // fill code input in UI: find or create card and open keyboard
  const found = db[code];
  if(found){
    // ensure item exists in allItems
    let card = document.querySelector(`.item[data-code="${code}"]`);
    if(!card){
      allItems.unshift({ code, name: found, unit:'', price:0, docQty:0 });
      render(allItems);
      card = document.querySelector(`.item[data-code="${code}"]`);
    }
    if(card){
      card.classList.add('found');
      setTimeout(()=>card.classList.remove('found'), 2200);
      card.classList.remove('hidden');
      setTimeout(()=>card.scrollIntoView({ behavior:'smooth', block:'center' }), 160);
      const input = card.querySelector('input[data-code]');
      if(input) setTimeout(()=>{ input.focus(); openKeyboardFor(input); }, 320);
    }
  } else {
    const create = confirm(`–ö–æ–¥ ${code} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ. –î–æ–±–∞–≤–∏—Ç—å –∫–∞–∫ –Ω–æ–≤—ã–π —Ç–æ–≤–∞—Ä?`);
    if(create){
      const name = prompt('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞', '') || `–¢–æ–≤–∞—Ä ${code}`;
      db[code] = name;
      barcodeDB = db;
      saveDB();
      allItems.unshift({ code, name, unit:'', price:0, docQty:0 });
      render(allItems);
      const newCard = document.querySelector(`.item[data-code="${code}"]`);
      if(newCard){
        newCard.classList.add('found');
        setTimeout(()=>newCard.classList.remove('found'), 2200);
        setTimeout(()=> newCard.scrollIntoView({ behavior:'smooth', block:'center' }), 160);
        const input = newCard.querySelector('input[data-code]');
        if(input) setTimeout(()=>{ input.focus(); openKeyboardFor(input); }, 320);
      }
    }
  }
}

/* =========================
   UI actions wiring
   ========================= */
scanBtn.addEventListener('click', async ()=>{
  if(!scanning) await startCamera();
  else stopCamera();
});
closeScannerBtn.addEventListener('click', stopCamera);
deviceSelect.addEventListener('change', async ()=>{
  currentDeviceId = deviceSelect.value;
  if(scanning){
    try{ reader.reset(); }catch(e){}
    scanning = false;
  }
  await startCamera();
});
torchBtn.addEventListener('click', toggleTorch);

/* =========================
   Init on load
   ========================= */
window.addEventListener('DOMContentLoaded', async ()=>{
  // load DB from Scaner.html storage (localStorage 'barcodeDB')
  loadBarcodeDB();
  buildAllItemsFromDB();

  // restore autosave session if exists
  const currentLocalkaId = (window.localkaData && window.localkaData.docId) ? window.localkaData.docId : 'loc_' + new Date().toISOString().slice(0,10);
  const sessionKey = 'autosave_session_' + currentLocalkaId;
  const savedSession = localStorage.getItem(sessionKey);
  if(savedSession){
    try{
      const session = JSON.parse(savedSession);
      allItems = session.items || allItems;
      sessionValues = session.values || {};
    }catch(e){}
  }

  render(allItems);

  // enumerate cameras (non-blocking)
  if(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices){
    try{ await enumerateCameras(); }catch(e){}
  }

  // warm permission check to populate labels on some devices
  try{
    const s = await navigator.mediaDevices.getUserMedia({video:true});
    s.getTracks().forEach(t=>t.stop());
    await enumerateCameras();
  }catch(e){ /* ignore */ }
});

/* stop camera on unload */
window.addEventListener('pagehide', ()=>{ stopCamera(); });
window.addEventListener('beforeunload', ()=>{ stopCamera(); });

/* expose for debug */
window._recount = { db, barcodeDB, allItems, startCamera, stopCamera, render };

</script>
</body>
</html>
