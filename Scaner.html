<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
<title>Monkey Quest — мобильный (multitouch)</title>
<style>
  :root{--bg1:#f3f6fa;--bg2:#e9eef6;--panel:#ffffff;--accent:#ffd77a;--dark:#07323a}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),var(--bg2));font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;-webkit-text-size-adjust:100%}
  #wrap{display:flex;flex-direction:column;height:100vh;overflow:hidden}
  header{padding:10px 12px;display:flex;align-items:center;justify-content:space-between;background:linear-gradient(180deg,var(--panel),#f1f5f9);box-shadow:0 6px 18px rgba(13,40,58,0.06);z-index:20}
  h1{font-size:16px;margin:0;color:var(--dark)}
  #hud{display:flex;gap:10px;align-items:center}
  .pill{background:linear-gradient(180deg,var(--panel),#f7fafc);padding:6px 10px;border-radius:12px;font-weight:700;border:1px solid rgba(7,34,51,0.06);color:var(--dark)}
  main{flex:1;position:relative;min-height:0}
  canvas#c{position:absolute;left:0;top:0;width:100vw;height:calc(100vh - 56px);display:block;z-index:0}
  .ui-layer{position:absolute;left:0;top:0;width:100%;height:100%;z-index:30;pointer-events:none}
  #overlay{position:fixed;left:12px;bottom:12px;display:flex;gap:12px;align-items:end;pointer-events:none;z-index:35}
  .joy{width:110px;height:110px;border-radius:999px;background:rgba(7,34,51,0.05);display:flex;align-items:center;justify-content:center;pointer-events:auto;touch-action:none;border:1px solid rgba(7,34,51,0.06)}
  .thumb{width:48px;height:48px;border-radius:999px;background:linear-gradient(180deg,var(--accent),#ffc857);transform:translate(0,0)}
  .jump-circle{position:fixed;right:12px;bottom:12px;width:110px;height:110px;border-radius:999px;background:rgba(255,255,255,0.18);display:flex;align-items:center;justify-content:center;pointer-events:auto;border:1px solid rgba(7,34,51,0.06);z-index:35}
  .jump-arrow{width:0;height:0;border-left:14px solid transparent;border-right:14px solid transparent;border-bottom:22px solid var(--dark);transform:translateY(-3px)}
  #restartSmall{position:fixed;left:12px;top:12px;pointer-events:auto;width:44px;height:44px;border-radius:8px;background:linear-gradient(180deg,var(--panel),#f7fafc);display:flex;align-items:center;justify-content:center;border:1px solid rgba(7,34,51,0.06);box-shadow:0 4px 10px rgba(13,40,58,0.04);z-index:35}
  #hint{position:fixed;left:12px;top:64px;background:rgba(255,255,255,0.95);padding:8px;border-radius:8px;font-size:13px;border:1px solid rgba(7,34,51,0.04);z-index:35;pointer-events:auto}
  #errorBox{position:absolute;left:12px;right:12px;top:50%;transform:translateY(-50%);background:#fff0f0;color:#6b0b0b;padding:12px;border-radius:8px;border:1px solid #ebb;z-index:50;display:none}
  footer{padding:8px 12px;font-size:12px;color:#3b5566;background:linear-gradient(180deg,transparent,#f1f5f9);z-index:20}
  @media(min-width:760px){ .joy{width:140px;height:140px}.thumb{width:64px;height:64px}.jump-circle{width:140px;height:140px} }
</style>
</head>
<body>
<div id="wrap">
  <header>
    <h1>Monkey Quest</h1>
    <div id="hud">
      <div class="pill">Очки: <span id="score">0</span></div>
      <div class="pill">Время: <span id="time">60</span>s</div>
      <div class="pill">Уровень: <span id="level">1</span></div>
    </div>
  </header>

  <main>
    <canvas id="c" role="img" aria-label="Игровое поле"></canvas>

    <div class="ui-layer" aria-hidden="false">
      <div id="overlay">
        <div class="joy" id="joy" aria-hidden="true">
          <div class="thumb" id="thumb"></div>
        </div>
      </div>

      <div id="restartSmall" title="Рестарт" aria-label="Рестарт">
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M21 12a9 9 0 1 0-2.64 6.09" stroke="#07323a" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M21 4v6h-6" stroke="#07323a" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>

      <div id="hint">Джойстик слева — ходьба, правая часть — вращение (yaw + pitch). Можно одновременно ходить и смотреть вверх/вниз.</div>

      <div class="jump-circle" id="jumpBtn" aria-label="Прыжок" title="Прыжок">
        <div class="jump-arrow" aria-hidden="true"></div>
      </div>
    </div>

    <div id="errorBox" role="alert"></div>
  </main>

  <footer>Открой в мобильном Safari/Chrome. Левая рука — джойстик, правая — поворот.</footer>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
/* Полный мобильный файл с multitouch:
   - отдельные тачи для джойстика и поворота (joyTouchId, rotTouchId)
   - возможность одновременного движения и вертикального/горизонтального поворота
   - правый регион сужен, чтобы не конфликтовал с кнопкой прыжка
   - безопасная инициализация WebGL/renderer и resize
*/

(function(){
  // --- базовые проверки и DOM ---
  function showError(msg){ const box = document.getElementById('errorBox'); box.textContent = msg; box.style.display = 'block'; }
  function webglAvailable(){ try { const c=document.createElement('canvas'); return !!(window.WebGLRenderingContext && (c.getContext('webgl') || c.getContext('experimental-webgl'))); } catch(e){ return false; } }
  if(!webglAvailable()){ showError('WebGL не поддерживается. Откройте в мобильном Safari или Chrome.'); return; }

  const canvas = document.getElementById('c');
  const scoreEl = document.getElementById('score');
  const timeEl = document.getElementById('time');
  const levelEl = document.getElementById('level');
  const joy = document.getElementById('joy');
  const thumb = document.getElementById('thumb');
  const jumpBtn = document.getElementById('jumpBtn');
  const restartSmall = document.getElementById('restartSmall');

  // --- three.js init ---
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  renderer.setClearColor(0xe9eef6);
  renderer.shadowMap.enabled = true;

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 200);
  camera.position.set(0, 8, 12);

  // lights
  const amb = new THREE.AmbientLight(0xffffff, 0.7); scene.add(amb);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(4,10,6); dir.castShadow=true; dir.shadow.mapSize.set(1024,1024); scene.add(dir);
  const rim = new THREE.DirectionalLight(0xfff6e6, 0.15); rim.position.set(-6,6,-4); scene.add(rim);

  // ground + grid
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(40,40), new THREE.MeshStandardMaterial({color:0xe6eef4, metalness:0, roughness:0.9}));
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);
  const grid = new THREE.GridHelper(40,20,0xcfdde6,0xddeaf0); grid.material.opacity = 0.45; grid.material.transparent = true; scene.add(grid);

  // monkey primitive
  const monkey = new THREE.Group();
  const body = new THREE.Mesh(new THREE.SphereGeometry(0.7,24,16), new THREE.MeshStandardMaterial({color:0x9c6b3a, metalness:0.05, roughness:0.6})); body.castShadow=true; body.position.set(0,0.7,0); monkey.add(body);
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.45,20,16), new THREE.MeshStandardMaterial({color:0xab7a4a})); head.castShadow=true; head.position.set(0,1.45,0.08); monkey.add(head);
  const face = new THREE.Mesh(new THREE.SphereGeometry(0.28,12,10), new THREE.MeshStandardMaterial({color:0xfff1e6})); face.position.set(0,1.35,0.3); monkey.add(face);
  const armL = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,0.9,12), new THREE.MeshStandardMaterial({color:0x9c6b3a})); armL.position.set(-0.95,0.8,0); armL.rotation.z=0.2; armL.castShadow=true;
  const armR = armL.clone(); armR.position.x = 0.95; armR.rotation.z = -0.2;
  const legL = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,0.9,12), new THREE.MeshStandardMaterial({color:0x9c6b3a})); legL.position.set(-0.36,0.05,0); legL.rotation.z=0.05; legL.castShadow=true;
  const legR = legL.clone(); legR.position.x = 0.36;
  const tail = new THREE.Mesh(new THREE.TorusGeometry(0.5,0.08,8,16,Math.PI*1.1), new THREE.MeshStandardMaterial({color:0x9c6b3a})); tail.rotation.x = Math.PI/2; tail.position.set(0,0.5,-0.7); tail.castShadow=true;
  monkey.add(armL, armR, legL, legR, tail);
  monkey.position.set(0,0.02,0);
  scene.add(monkey);

  // boxes + bananas
  const boxes = [];
  for(let i=0;i<5;i++){
    const box = new THREE.Mesh(new THREE.BoxGeometry(2.4,1.4,2.4), new THREE.MeshStandardMaterial({color:0xc6d7df}));
    box.castShadow=true; box.receiveShadow=true; box.position.set((Math.random()-0.5)*28,0.7,(Math.random()-0.5)*28);
    scene.add(box); boxes.push(box);
  }

  let bananas = [];
  function makeBananaMesh(){
    const g = new THREE.Group();
    const yellow = new THREE.MeshStandardMaterial({color:0xffd166, emissive:0xffe5b4, metalness:0.05, roughness:0.3});
    for(let i=0;i<5;i++){ const s = new THREE.Mesh(new THREE.SphereGeometry(0.14,12,10), yellow); s.position.set((i-2)*0.12,0,Math.sin((i-2)/3)*0.1); g.add(s); }
    const tip = new THREE.Mesh(new THREE.SphereGeometry(0.05,10,8), new THREE.MeshStandardMaterial({color:0x7f4c00})); tip.position.set(-0.28,0,0.03); g.add(tip);
    return g;
  }
  function spawnBananas(n=10){
    bananas.forEach(b=>scene.remove(b.mesh)); bananas=[];
    for(let i=0;i<n;i++){
      const mesh = makeBananaMesh();
      let x,z,ok;
      do{
        x = (Math.random()-0.5)*30; z = (Math.random()-0.5)*30;
        ok = Math.hypot(x - monkey.position.x, z - monkey.position.z) > 3;
        boxes.forEach(bx=>{ if(ok){ const dx = x - bx.position.x, dz = z - bx.position.z; if(Math.abs(dx) < 2.7 && Math.abs(dz) < 2.7) ok = false; }});
      } while(!ok);
      mesh.position.set(x, 0.14 + Math.random()*0.28, z); mesh.rotation.y = Math.random()*Math.PI*2;
      scene.add(mesh); bananas.push({mesh, r:0.28});
    }
  }
  spawnBananas(10);

  // camera target helper
  const camTarget = new THREE.Vector3();
  function updateCamera(){
    const desired = new THREE.Vector3(monkey.position.x, monkey.position.y + 4.2, monkey.position.z + 9.2);
    camera.position.lerp(desired, 0.12);
    camTarget.set(monkey.position.x, monkey.position.y + 1.2, monkey.position.z);
    camera.lookAt(camTarget);
  }

  // state/physics
  const state = { vel: new THREE.Vector3(0,0,0), onGround:true, move: new THREE.Vector2(0,0), jumpImpulse:5.6, gravity:-18, maxSpeed:5 };
  let score = 0, totalTime = 60, timeLeft = totalTime, level = 1;
  scoreEl.textContent = score; timeEl.textContent = timeLeft; levelEl.textContent = level;

  // resize
  function resizeRenderer(){
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    renderer.setPixelRatio(dpr);
    const w = window.innerWidth;
    const h = window.innerHeight - document.querySelector('header').offsetHeight;
    renderer.setSize(w, h, false);
    camera.aspect = w / h; camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', resizeRenderer);
  resizeRenderer();

  // ---- JOYSTICK (left) ----
  let joyTouchId = null;
  let joyActive = false;
  let joyCenter = {x:0,y:0}, joyRadius = 42;
  const invert = true; // reverse vertical by default

  function updateJoy(cx, cy){
    const dx = cx - joyCenter.x, dy = cy - joyCenter.y;
    const dist = Math.hypot(dx, dy);
    const nx = dx / (dist || 1), ny = dy / (dist || 1);
    const mag = Math.min(dist / joyRadius, 1);
    const forwardY = invert ? ny : -ny;
    state.move.x = (Math.abs(nx) < 0.12) ? 0 : nx * mag;
    state.move.y = (Math.abs(forwardY) < 0.12) ? 0 : forwardY * mag;
    thumb.style.transform = `translate(${state.move.x * (joyRadius-18)}px, ${-state.move.y * (joyRadius-18)}px)`;
  }
  function endJoy(){ joyActive = false; joyTouchId = null; state.move.set(0,0); thumb.style.transform = 'translate(0,0)'; }

  // ---- ROTATION (right) ----
  let rotTouchId = null;
  let rotateActive = false;
  let lastRotX = 0, lastRotY = 0;
  const PITCH_MIN = -0.8, PITCH_MAX = 0.6;
  const SENS_X = 0.006, SENS_Y = 0.004;

  // helper to find touch by id
  function findTouchById(touches, id){
    for(let i=0;i<touches.length;i++) if(touches[i].identifier === id) return touches[i];
    return null;
  }

  // --- multitouch handlers ---
  window.addEventListener('touchstart', (e)=>{
    for(let i=0;i<e.changedTouches.length;i++){
      const t = e.changedTouches[i];
      const x = t.clientX, y = t.clientY;
      const W = window.innerWidth;

      const leftZone = x < W * 0.45;
      const rightZone = x > W * 0.55;

      // prioritize touches inside visual joystick element
      const rect = joy.getBoundingClientRect();
      const inJoyVisual = x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;

      if((leftZone || inJoyVisual) && joyTouchId === null){
        joyTouchId = t.identifier;
        joyActive = true;
        joyCenter = {x: rect.left + rect.width/2, y: rect.top + rect.height/2};
        joyRadius = Math.min(rect.width, rect.height)/2 - 6;
        updateJoy(t.clientX, t.clientY);
        e.preventDefault();
      } else if(rightZone && rotTouchId === null){
        // bind rotation touch
        rotTouchId = t.identifier;
        rotateActive = true;
        lastRotX = t.clientX;
        lastRotY = t.clientY;
        e.preventDefault();
      }
      // otherwise ignore additional touches
    }
  }, {passive:false});

  window.addEventListener('touchmove', (e)=>{
    // joystick move
    if(joyTouchId !== null){
      const jt = findTouchById(e.touches, joyTouchId);
      if(jt){
        updateJoy(jt.clientX, jt.clientY);
      }
    }

    // rotation move
    if(rotTouchId !== null && rotateActive){
      const rt = findTouchById(e.touches, rotTouchId);
      if(rt){
        const dx = rt.clientX - lastRotX;
        const dy = rt.clientY - lastRotY;
        lastRotX = rt.clientX; lastRotY = rt.clientY;
        monkey.rotation.y -= dx * SENS_X;
        let proposedPitch = monkey.rotation.x - dy * SENS_Y;
        proposedPitch = Math.max(PITCH_MIN, Math.min(PITCH_MAX, proposedPitch));
        monkey.rotation.x = proposedPitch;
      }
    }

    // block scrolling when interacting
    e.preventDefault();
  }, {passive:false});

  window.addEventListener('touchend', (e)=>{
    for(let i=0;i<e.changedTouches.length;i++){
      const t = e.changedTouches[i];
      if(t.identifier === joyTouchId) endJoy();
      if(t.identifier === rotTouchId){ rotTouchId = null; rotateActive = false; }
    }
  }, {passive:true});
  window.addEventListener('touchcancel', (e)=>{
    for(let i=0;i<e.changedTouches.length;i++){
      const t = e.changedTouches[i];
      if(t.identifier === joyTouchId) endJoy();
      if(t.identifier === rotTouchId){ rotTouchId = null; rotateActive = false; }
    }
  }, {passive:true});

  // jump + restart handlers
  function tryJump(){ if(state.onGround){ state.vel.y = state.jumpImpulse; state.onGround = false; } }
  jumpBtn.addEventListener('touchstart', (e)=>{ e.stopPropagation(); e.preventDefault(); tryJump(); }, {passive:false});
  restartSmall.addEventListener('touchstart', (e)=>{ e.stopPropagation(); e.preventDefault(); resetGame(); }, {passive:false});

  // physics & game logic
  let walkPhase = 0;
  function physicsStep(dt){
    const camYaw = Math.atan2(camera.position.x - monkey.position.x, camera.position.z - monkey.position.z);
    const cos = Math.cos(camYaw), sin = Math.sin(camYaw);
    const input = new THREE.Vector3(state.move.x, 0, state.move.y);
    const worldDir = new THREE.Vector3(input.x * cos - input.z * sin, 0, input.x * sin + input.z * cos);
    const targetVel = worldDir.clone().multiplyScalar(state.maxSpeed * (1 + 0.08*level));
    const acc = 24;
    state.vel.x = THREE.MathUtils.damp(state.vel.x, targetVel.x, acc, dt);
    state.vel.z = THREE.MathUtils.damp(state.vel.z, targetVel.z, acc, dt);
    state.vel.y += state.gravity * dt;

    monkey.position.x += state.vel.x * dt;
    monkey.position.y += state.vel.y * dt;
    monkey.position.z += state.vel.z * dt;

    if(monkey.position.y <= 0.02){ monkey.position.y = 0.02; state.vel.y = 0; state.onGround = true; } else state.onGround = false;

    boxes.forEach(b=>{
      const minX = b.position.x - 1.2, maxX = b.position.x + 1.2;
      const minZ = b.position.z - 1.2, maxZ = b.position.z + 1.2;
      if(monkey.position.x > minX - 0.9 && monkey.position.x < maxX + 0.9 &&
         monkey.position.z > minZ - 0.9 && monkey.position.z < maxZ + 0.9){
        const dx = monkey.position.x - b.position.x, dz = monkey.position.z - b.position.z;
        const d = Math.hypot(dx, dz) || 0.001;
        const push = (1.2 + 0.9) - d;
        if(push > 0){ monkey.position.x += (dx/d) * push; monkey.position.z += (dz/d) * push; state.vel.x *= 0.4; state.vel.z *= 0.4; }
      }
    });

    for(let i=bananas.length-1;i>=0;i--){
      const c = bananas[i];
      const d = Math.hypot(monkey.position.x - c.mesh.position.x, monkey.position.z - c.mesh.position.z);
      if(d < 0.9 && Math.abs(monkey.position.y - c.mesh.position.y) < 1.6){
        scene.remove(c.mesh); bananas.splice(i,1); score += 10; scoreEl.textContent = score; if(bananas.length === 0) levelUp();
      } else { c.mesh.position.y = 0.14 + Math.sin(performance.now()*0.004 + i)*0.06; c.mesh.rotation.y += 0.02; }
    }

    const speed = Math.hypot(state.vel.x, state.vel.z);
    walkPhase += speed * dt * 6;
    const lean = Math.sin(walkPhase) * Math.min(0.16, speed*0.06);
    body.rotation.z = THREE.MathUtils.lerp(body.rotation.z, lean, 0.12);
    head.rotation.y = THREE.MathUtils.lerp(head.rotation.y, -state.vel.x*0.06, 0.12);
    armL.rotation.x = 0.2 + Math.sin(walkPhase)*0.5*speed;
    armR.rotation.x = -0.2 + Math.sin(walkPhase + Math.PI)*0.5*speed;
  }

  function levelUp(){ level++; levelEl.textContent = level; timeLeft = Math.min(totalTime, timeLeft + 18); spawnBananas(8 + Math.min(6, level)); boxes.forEach(b=>{ b.position.x = (Math.random()-0.5)*28; b.position.z = (Math.random()-0.5)*28; }); }
  function resetGame(){ score = 0; scoreEl.textContent = score; level = 1; levelEl.textContent = level; timeLeft = totalTime; timeEl.textContent = Math.round(timeLeft); monkey.position.set(0,0.02,0); state.vel.set(0,0,0); spawnBananas(10); }

  function spawnBananas(n=10){
    bananas.forEach(b=>scene.remove(b.mesh)); bananas=[];
    for(let i=0;i<n;i++){
      const mesh = makeBananaMesh();
      let x,z,ok;
      do{
        x = (Math.random()-0.5)*30; z = (Math.random()-0.5)*30;
        ok = Math.hypot(x - monkey.position.x, z - monkey.position.z) > 3;
        boxes.forEach(bx=>{ if(ok){ const dx = x - bx.position.x, dz = z - bx.position.z; if(Math.abs(dx) < 2.7 && Math.abs(dz) < 2.7) ok = false; }});
      } while(!ok);
      mesh.position.set(x, 0.14 + Math.random()*0.28, z); mesh.rotation.y = Math.random()*Math.PI*2;
      scene.add(mesh); bananas.push({mesh, r:0.28});
    }
  }

  // animate loop
  let last = performance.now(), accum = 0;
  function animate(now){
    const dt = Math.min((now - last)/1000, 0.05); last = now;
    physicsStep(dt);
    updateCamera();
    renderer.render(scene, camera);
    accum += dt;
    if(accum >= 1){ accum = 0; timeLeft = Math.max(0, timeLeft - 1); timeEl.textContent = Math.round(timeLeft); if(timeLeft <= 0){ setTimeout(()=>{ alert('Время вышло! Очков: '+score); resetGame(); }, 60); } }
    requestAnimationFrame(animate);
  }

  // final init
  resizeRenderer();
  requestAnimationFrame(animate);

})();
</script>
</body>
</html>
