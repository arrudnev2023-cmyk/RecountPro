<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Fight</title>
<style>
  :root{
    --bg:#0b1020;
    --ground:#151827;
    --ui:#11131a;
    --accent:#e3a34b;
    --health-1:#e74c3c;
    --health-2:#2ecc71;
    --btn:#1b222e;
    --btn-active:#2b3340;
    --text:#e6eef8;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#061025);color:var(--text);font-family:Inter,Segoe UI,Roboto,Arial;}
  #gameWrap{display:flex;flex-direction:column;height:100%;align-items:center;justify-content:center;padding:10px;box-sizing:border-box}
  canvas{background:linear-gradient(180deg,#07121f, #061217);border-radius:12px;max-width:100%;width:100%;height:auto;box-shadow:0 8px 30px rgba(0,0,0,.6);}
  .ui{width:100%;max-width:920px;margin-top:10px;display:flex;justify-content:space-between;align-items:center;gap:10px}
  .health{flex:1;background:var(--ui);padding:8px;border-radius:10px;display:flex;flex-direction:column;gap:6px}
  .bars{display:flex;gap:10px;align-items:center}
  .bar{width:100%;height:14px;background:#111217;border-radius:8px;position:relative;overflow:hidden}
  .bar > .fill{height:100%;background:linear-gradient(90deg,var(--health-2),#18b26b);width:100%;transition:width .15s linear}
  .bar.enemy > .fill{background:linear-gradient(90deg,#ff7b67,var(--health-1))}
  .labels{display:flex;justify-content:space-between;font-size:12px;opacity:.9}
  .controls{display:flex;gap:8px;align-items:center}
  .btn{background:var(--btn);color:var(--text);border-radius:8px;padding:8px 10px;font-weight:600;border:none}
  .touch{display:none;position:fixed;left:0;right:0;bottom:0;padding:12px;background:transparent;pointer-events:none}
  .touch-inner{max-width:920px;margin:0 auto;display:flex;justify-content:space-between;align-items:flex-end;gap:12px;pointer-events:auto}
  .pad{display:grid;grid-template-columns:repeat(3,72px);gap:8px;background:rgba(0,0,0,.18);padding:8px;border-radius:12px}
  .pad .controller{width:72px;height:56px;background:var(--btn);display:flex;align-items:center;justify-content:center;border-radius:8px;touch-action:none}
  .action-pad{display:flex;flex-direction:column;gap:8px}
  .action-row{display:flex;gap:8px}
  .small{font-size:12px;opacity:.85}
  #msg{position:absolute;top:18px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.35);padding:6px 12px;border-radius:8px;font-weight:700}
  @media (max-width:720px){
    .touch{display:block}
    .ui{display:none}
  }
  .credits{font-size:12px;opacity:.7;margin-top:6px;text-align:center}
</style>
</head>
<body>
<div id="gameWrap">
  <div style="position:relative;width:100%;max-width:920px">
    <div id="msg">Нажми любую кнопку чтобы начать</div>
    <canvas id="c" width="920" height="480"></canvas>
  </div>

  <div class="ui" aria-hidden="true">
    <div class="health">
      <div class="labels"><div>Player</div><div id="pScore">0</div></div>
      <div class="bars"><div class="bar" style="width:100%"><div id="pHealth" class="fill" style="width:100%"></div></div></div>
    </div>
    <div class="health">
      <div class="labels"><div>Enemy</div><div id="eScore">0</div></div>
      <div class="bars"><div class="bar enemy" style="width:100%"><div id="eHealth" class="fill" style="width:100%"></div></div></div>
    </div>
    <div class="controls">
      <button id="restart" class="btn">Restart</button>
      <div class="small">Клавиши: A/D — влево/вправо, W — прыжок, J — слабая, K — сильная, L — блок</div>
    </div>
  </div>

  <div class="touch" id="touchArea" aria-hidden="false">
    <div class="touch-inner">
      <div class="pad" id="leftPad">
        <div class="controller" data-action="left">◀</div>
        <div class="controller" data-action="stop">•</div>
        <div class="controller" data-action="right">▶</div>
        <div class="controller" data-action="jump">▲</div>
        <div class="controller" data-action="block">▣</div>
        <div class="controller" data-action="crouch">▼</div>
      </div>

      <div class="action-pad">
        <div class="action-row">
          <div class="controller" data-action="light">Light</div>
          <div class="controller" data-action="heavy">Heavy</div>
        </div>
        <div class="action-row">
          <div class="controller" data-action="special">Special</div>
        </div>
      </div>
    </div>
  </div>

  <div class="credits">Мини‑клон Shadow Fight — простая демоверсия. Создано для учебных целей.</div>
</div>

<script>
/* --- Игра: базовый файтинг в canvas --- */
const canvas = document.getElementById('c'), ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;
const DPR = Math.max(1, window.devicePixelRatio || 1);
function resize() {
  const wrap = document.getElementById('gameWrap');
  const maxW = Math.min(window.innerWidth - 20, 920);
  const ratio = 920/480;
  let cw = Math.round(maxW), ch = Math.round(cw / ratio);
  canvas.style.width = cw + 'px';
  canvas.style.height = ch + 'px';
  canvas.width = cw * DPR;
  canvas.height = ch * DPR;
  ctx.setTransform(DPR,0,0,DPR,0,0);
  W = cw; H = ch;
}
resize();
window.addEventListener('resize', resize);

/* Game constants */
const GROUND_Y = 0.78; // relative ground height
const GRAVITY = 1600; // px/s^2
const STAGE_PADDING = 60;

/* Utility */
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function now(){return performance.now()/1000}

/* Player class */
class Fighter {
  constructor(x,side='left'){
    this.x = x; this.y = 0; this.vx = 0; this.vy = 0;
    this.w = 70; this.h = 110;
    this.facing = side==='left'?1:-1;
    this.color = side==='left'?'#e6eef8':'#111215';
    this.shadow = side==='left'?'#0b84ff':'#ff6b6b';
    this.onGround = false;
    this.hp = 100;
    this.maxHp = 100;
    this.state = 'idle'; // idle, run, jump, attack, hit, block
    this.attackTimer = 0;
    this.blocking = false;
    this.combo = 0;
    this.score = 0;
    this.invul = 0;
  }
  rect(){ return {x:this.x-this.w/2, y:this.y-this.h, w:this.w, h:this.h}; }
  center(){ return {x:this.x, y:this.y-this.h/2}; }
  update(dt){
    // physics
    this.vy += GRAVITY*dt;
    this.x += this.vx*dt;
    this.y += this.vy*dt;
    // ground clamp
    const ground = H*GROUND_Y;
    if(this.y > ground){ this.y = ground; this.vy = 0; this.onGround = true; }
    else this.onGround = false;
    // friction
    if(this.onGround && Math.abs(this.vx) > 1) this.vx *= 0.9;
    else if(this.onGround) this.vx = 0;
    // attack timer
    if(this.attackTimer>0) this.attackTimer = Math.max(0, this.attackTimer - dt);
    if(this.invul>0) this.invul = Math.max(0, this.invul - dt);
  }
  draw(ctx){
    ctx.save();
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.22)';
    const shW = this.w*1.1;
    ctx.beginPath();
    ctx.ellipse(this.x, H*GROUND_Y+6, shW/2, 12, 0,0,Math.PI*2);
    ctx.fill();
    // body (silhouette)
    ctx.translate(this.x, this.y - this.h);
    ctx.scale(this.facing,1);
    // body box
    ctx.fillStyle = (this.state==='hit')? '#ffb3b3' : this.color;
    ctx.fillRect(-this.w/2,0,this.w,this.h);
    // simple head
    ctx.fillStyle = this.shadow;
    ctx.fillRect(-this.w/4, -this.h*0.12, this.w/2, this.h*0.12);
    // weapon arc during attack
    if(this.state==='attack' && this.attackTimer>0){
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255,255,255,0.6)';
      ctx.lineWidth = 8;
      const angle = Math.PI*0.27;
      ctx.arc(this.w/2 - 6, this.h*0.2, 46, -angle, angle);
      ctx.stroke();
    }
    ctx.restore();
    // hp bar above
    ctx.fillStyle = '#00000044';
    ctx.fillRect(this.x - 50, this.y - this.h - 24, 100, 10);
    ctx.fillStyle = '#ff4757';
    const hpPerc = clamp(this.hp/this.maxHp,0,1);
    ctx.fillRect(this.x - 50, this.y - this.h - 24, 100*hpPerc, 10);
    ctx.strokeStyle = '#00000033';
    ctx.strokeRect(this.x - 50, this.y - this.h - 24, 100, 10);
  }
  tryAttack(type){
    if(this.attackTimer>0) return false;
    if(type==='light'){
      this.attackTimer = 0.32; this.state='attack'; this.combo++;
      return {damage:8, range:56, knock:120, stun:0.08};
    } else if(type==='heavy'){
      this.attackTimer = 0.6; this.state='attack'; this.combo=0;
      return {damage:18, range:74, knock:260, stun:0.16};
    } else if(type==='special'){
      this.attackTimer = 0.9; this.state='attack'; this.combo=0;
      return {damage:26, range:88, knock:320, stun:0.25};
    }
  }
  receive(dmg, knock, attacker){
    if(this.invul>0) return false;
    if(this.blocking){
      // block reduces damage and knock
      dmg = Math.max(0, Math.floor(dmg*0.38));
      knock *= 0.3;
      this.state = 'block';
      this.invul = 0.09;
    } else {
      this.hp = Math.max(0, this.hp - dmg);
      this.state = 'hit';
      this.invul = 0.12;
    }
    // apply knockback
    this.vx += (this.x < attacker.x ? -1 : 1) * (knock/120);
    // small stun effect handled by state duration externally
    return true;
  }
}

/* Game state */
let player = new Fighter(200,'left');
let enemy = new Fighter(720,'right');
enemy.color = '#22262f'; enemy.shadow = '#ff6b6b';
player.score = 0; enemy.score = 0;
let last = now(); let running = false;
let messageEl = document.getElementById('msg');
const pHealthEl = document.getElementById('pHealth'), eHealthEl = document.getElementById('eHealth');
const pScoreEl = document.getElementById('pScore'), eScoreEl = document.getElementById('eScore');

/* Controls */
const keys = {};
window.addEventListener('keydown', e=>{
  keys[e.key.toLowerCase()] = true;
  startIfNeeded();
});
window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; });

function startIfNeeded(){ if(!running){ running = true; messageEl.style.display='none'; last = now(); loop(); } }

/* Touch controls */
document.querySelectorAll('.controller').forEach(btn=>{
  btn.addEventListener('touchstart', e=>{
    e.preventDefault();
    const a = btn.dataset.action;
    handleTouch(a, true);
    startIfNeeded();
  });
  btn.addEventListener('touchend', e=>{
    e.preventDefault();
    const a = btn.dataset.action;
    handleTouch(a, false);
  });
});
function handleTouch(action,down){
  // map to internal key states
  const map = {
    left: 'a', right: 'd', jump: 'w',
    light: 'j', heavy: 'k', special: 'u',
    block: 'l', crouch: 's', stop: 'stop'
  };
  if(map[action]) keys[map[action]] = down;
}

/* Restart */
document.getElementById('restart').addEventListener('click', reset);
function reset(){
  player = new Fighter(220,'left');
  enemy = new Fighter(W-220,'right');
  enemy.color = '#22262f'; enemy.shadow = '#ff6b6b';
  running = false;
  messageEl.style.display = '';
  updateUI();
}

/* Simple AI for enemy */
function enemyAI(dt){
  // basic behavior: move toward player, attack if in range, occasionally block/dodge
  const dist = Math.abs(enemy.x - player.x);
  // decide facing
  enemy.facing = enemy.x < player.x ? 1 : -1;
  // movement toward player
  if(dist > 180){
    enemy.vx = (player.x < enemy.x) ? -120 : 120;
    enemy.state = 'run';
  } else {
    enemy.vx = 0;
    if(enemy.attackTimer<=0){
      // choose attack by probability
      const r = Math.random();
      if(r<0.55) enemy.tryAttack('light');
      else if(r<0.85) enemy.tryAttack('heavy');
      else enemy.tryAttack('special');
    }
    // occasional block
    enemy.blocking = Math.random() < 0.02;
  }
  // jump randomly if player too close and low chance
  if(Math.random() < 0.005 && enemy.onGround) { enemy.vy = -520; enemy.onGround=false; }
}

/* Hit detection */
function checkHit(attacker, defender, attackData){
  if(!attackData) return false;
  // active window: attackTimer recently started
  const active = attacker.attackTimer > 0 && attacker.state === 'attack';
  if(!active) return false;
  const reach = attackData.range;
  const dx = Math.abs(attacker.x - defender.x);
  if(dx <= reach + (attacker.w/2) + (defender.w/2)){
    // hit
    if(defender.receive(attackData.damage, attackData.knock, attacker)){
      attacker.score += 1;
      return true;
    }
  }
  return false;
}

/* Update UI bars */
function updateUI(){
  pHealthEl.style.width = Math.round((player.hp/player.maxHp)*100) + '%';
  eHealthEl.style.width = Math.round((enemy.hp/enemy.maxHp)*100) + '%';
  pScoreEl.textContent = player.score;
  eScoreEl.textContent = enemy.score;
}

/* Game loop */
function loop(){
  const t = now(), dt = Math.min(0.033, t - last); last = t;
  // input -> player actions
  // movement
  let move = 0;
  if(keys['a']) move -= 1;
  if(keys['d']) move += 1;
  if(move!==0){
    player.vx = move * 220;
    player.facing = move>0?1:-1;
    if(player.onGround) player.state='run';
  } else {
    if(player.onGround && player.attackTimer<=0) player.state='idle';
    player.vx *= 0.95;
  }
  // jump
  if(keys['w'] && player.onGround){ player.vy = -560; player.onGround=false; }
  // block
  player.blocking = !!keys['l'];
  // attacks
  if(keys['j']) { player.tryAttack('light'); keys['j'] = false; } // discrete
  if(keys['k']) { player.tryAttack('heavy'); keys['k'] = false; }
  if(keys['u']) { player.tryAttack('special'); keys['u'] = false; }
  // update fighters
  player.update(dt);
  enemy.update(dt);
  // AI
  enemyAI(dt);
  // Hit checking (attacker first player then enemy)
  const pAttackWindow = (player.attackTimer>0 && player.state==='attack') ? true : false;
  if(pAttackWindow){
    // determine attack data based on remaining timer/length simple mapping
    // we stored attack data only when tryingAttack invoked; to simplify, infer by attackTimer length
  }
  // To know last attack type, we can store lastAttack when tryAttack called; adjust class
  // Quick patch: attach lastAttack to fighter when tryAttack returns value
  // (we implement tryAttack to set lastAttack)
  checkHit(player, enemy, player.lastAttack);
  checkHit(enemy, player, enemy.lastAttack);
  // update states if attack over
  if(player.attackTimer<=0 && player.state==='attack') player.state='idle';
  if(enemy.attackTimer<=0 && enemy.state==='attack') enemy.state='idle';
  // end round
  if(player.hp<=0 || enemy.hp<=0){
    if(player.hp<=0) enemy.score++;
    if(enemy.hp<=0) player.score++;
    // small flash message and reset positions
    messageEl.style.display='';
    messageEl.textContent = (player.hp<=0 ? 'Enemy wins! Tap to continue' : 'You win! Tap to continue');
    running=false;
    updateUI();
    return;
  }

  // draw
  draw(dt);
  updateUI();
  if(running) requestAnimationFrame(loop);
}

/* draw scene */
function draw(dt){
  ctx.clearRect(0,0,W,H);
  // background simple
  // distant mountains
  ctx.fillStyle = '#061324';
  ctx.fillRect(0,0,W,H);
  // ground
  ctx.fillStyle = '#0f1624';
  const gy = H*GROUND_Y;
  ctx.fillRect(0,gy, W, H-gy);
  // stage floor texture lines
  ctx.strokeStyle = '#00000022';
  ctx.lineWidth = 1;
  for(let i=0;i<10;i++){
    ctx.beginPath();
    ctx.moveTo(0, gy + 6 + i*6);
    ctx.lineTo(W, gy + 6 + i*6);
    ctx.stroke();
  }
  // apply simple camera clamp to keep fighters visible (not required but nice)
  // draw fighters
  player.draw(ctx);
  enemy.draw(ctx);

  // HUD central
  ctx.fillStyle = '#ffffffcc';
  ctx.font = '14px Inter, Arial';
  ctx.textAlign = 'center';
  ctx.fillText('Мини-клон Shadow Fight — demo', W/2, 22);

  // draw control hints for desktop
  ctx.font = '12px Inter, Arial';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#ffffff66';
  ctx.fillText('A D — move, W — jump, J/K — attacks, L — block', 14, H - 10);
}

/* Extend Fighter.tryAttack to store lastAttack */
Fighter.prototype.tryAttack = function(type){
  if(this.attackTimer>0) return false;
  if(type==='light'){
    this.attackTimer = 0.32; this.state='attack'; this.combo++;
    this.lastAttack = {damage:8, range:56, knock:120, stun:0.08};
    return this.lastAttack;
  } else if(type==='heavy'){
    this.attackTimer = 0.6; this.state='attack'; this.combo=0;
    this.lastAttack = {damage:18, range:74, knock:260, stun:0.16};
    return this.lastAttack;
  } else if(type==='special'){
    this.attackTimer = 0.9; this.state='attack'; this.combo=0;
    this.lastAttack = {damage:26, range:88, knock:320, stun:0.25};
    return this.lastAttack;
  }
};

/* Initial UI update */
updateUI();

/* Start on first interaction */
['pointerdown','touchstart','keydown','click'].forEach(ev=>{
  window.addEventListener(ev, startIfNeeded, {once:true,passive:true});
});

/* Prevent scrolling on touch area */
document.getElementById('touchArea').addEventListener('touchmove', e=>{ e.preventDefault(); }, {passive:false});
</script>
</body>
</html>
