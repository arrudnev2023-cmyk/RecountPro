<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Table Extractor</title>

  <!-- 1. –°–Ω–∞—á–∞–ª–∞ –æ–±—ä—è–≤–ª—è–µ–º Module –¥–ª—è OpenCV -->
  <script>
    let cvReady = false;

    // OpenCV –≤—ã–∑–æ–≤–µ—Ç —ç—Ç–æ, –∫–æ–≥–¥–∞ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–≥—Ä—É–∑–∏—Ç—Å—è
    var Module = {
      onRuntimeInitialized() {
        cvReady = true;
        console.log("‚úÖ OpenCV –≥–æ—Ç–æ–≤");
      }
    };
  </script>

  <!-- 2. –ü–æ–¥–∫–ª—é—á–∞–µ–º OpenCV (–±–µ–∑ async/defer) -->
  <script src="https://docs.opencv.org/4.x/opencv.js"></script>

  <!-- 3. –ü–æ–¥–∫–ª—é—á–∞–µ–º Tesseract -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    body { font-family: sans-serif; padding: 20px; }
    #preview { max-width: 400px; margin-top: 20px; display: block; }
    table { border-collapse: collapse; margin-top: 20px; }
    td, th { border: 1px solid #ccc; padding: 6px 10px; }
  </style>
</head>
<body>

<h2>üìÑ Table Extractor</h2>

<input type="file" id="fileInput" accept="image/*">
<img id="preview">
<div id="result"></div>

<script>
function waitForCV() {
  return new Promise((resolve, reject) => {
    if (cvReady) {
      console.log("‚öôÔ∏è OpenCV —É–∂–µ –≥–æ—Ç–æ–≤");
      return resolve();
    }

    let attempts = 0;
    const interval = setInterval(() => {
      attempts++;
      if (cvReady) {
        clearInterval(interval);
        console.log("‚öôÔ∏è OpenCV —Å—Ç–∞–ª –≥–æ—Ç–æ–≤ (–ø–æ —Ç–∞–π–º–µ—Ä—É)");
        resolve();
      }
      if (attempts > 100) {
        clearInterval(interval);
        console.error("‚ùå OpenCV —Ç–∞–∫ –∏ –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª—Å—è");
        reject(new Error("OpenCV –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª—Å—è"));
      }
    }, 100);
  });
}

document.getElementById("fileInput").addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  const img = document.getElementById("preview");
  img.src = URL.createObjectURL(file);

  img.onload = async () => {
    document.getElementById("result").innerHTML = "–û–±—Ä–∞–±–æ—Ç–∫–∞...";
    try {
      await waitForCV();
      const table = await extractTable(img);
      renderTable(table);
    } catch (err) {
      document.getElementById("result").innerHTML = "–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ OpenCV";
      console.error(err);
    }
  };
});

async function extractTable(img) {
  console.log("‚ñ∂Ô∏è –ù–∞—á–∏–Ω–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è");

  let src = cv.imread(img);
  let gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

  let thresh = new cv.Mat();
  cv.adaptiveThreshold(gray, thresh, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY_INV, 15, 10);

  let horizontal = thresh.clone();
  let horizontalsize = Math.floor(horizontal.cols / 20);
  let horizontalStructure = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(horizontalsize, 1));
  cv.erode(horizontal, horizontal, horizontalStructure);
  cv.dilate(horizontal, horizontal, horizontalStructure);

  let vertical = thresh.clone();
  let verticalsize = Math.floor(vertical.rows / 20);
  let verticalStructure = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(1, verticalsize));
  cv.erode(vertical, vertical, verticalStructure);
  cv.dilate(vertical, vertical, verticalStructure);

  let mask = new cv.Mat();
  cv.bitwise_and(horizontal, vertical, mask);

  let contours = new cv.MatVector();
  let hierarchy = new cv.Mat();
  cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  console.log("üîé –ù–∞–π–¥–µ–Ω–æ –∫–æ–Ω—Ç—É—Ä–æ–≤:", contours.size());

  let cells = [];

  for (let i = 0; i < contours.size(); i++) {
    let rect = cv.boundingRect(contours.get(i));
    if (rect.width < 40 || rect.height < 20) continue;

    let cellMat = src.roi(rect);
    let text = await ocrCell(cellMat);

    cells.push({ x: rect.x, y: rect.y, w: rect.width, h: rect.height, text });
    cellMat.delete();
  }

  src.delete(); gray.delete(); thresh.delete();
  horizontal.delete(); vertical.delete(); mask.delete();
  contours.delete(); hierarchy.delete();

  console.log("üì¶ –Ø—á–µ–µ–∫ –ø–æ—Å–ª–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏:", cells.length);

  cells.sort((a, b) => a.y - b.y || a.x - b.x);
  return buildTableStructure(cells);
}

async function ocrCell(mat) {
  let canvas = document.createElement("canvas");
  cv.imshow(canvas, mat);
  const { data: { text } } = await Tesseract.recognize(canvas, "rus+eng", {
    tessedit_pageseg_mode: 6
  });
  return text.trim();
}

function buildTableStructure(cells) {
  if (!cells.length) return [];
  let rows = [];
  let currentRow = [];
  let lastY = cells[0].y;

  for (let cell of cells) {
    if (Math.abs(cell.y - lastY) > 20) {
      rows.push(currentRow);
      currentRow = [];
      lastY = cell.y;
    }
    currentRow.push(cell);
  }
  rows.push(currentRow);
  console.log("üìä –°—Ç—Ä–æ–∫ –≤ —Ç–∞–±–ª–∏—Ü–µ:", rows.length);
  return rows;
}

function renderTable(rows) {
  if (!rows.length) {
    document.getElementById("result").innerHTML = "–¢–∞–±–ª–∏—Ü–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞";
    return;
  }

  let html = "<table>";
  for (let row of rows) {
    html += "<tr>";
    for (let cell of row) {
      html += `<td contenteditable="true">${cell.text}</td>`;
    }
    html += "</tr>";
  }
  html += "</table>";

  document.getElementById("result").innerHTML = html;
}
</script>

</body>
</html>
