<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>GTA-SA x Roblox — Mini Prototype</title>
<style>
  html,body{height:100%;margin:0;overflow:hidden;background:#87ceeb}
  canvas{display:block}
  #ui{position:absolute;left:12px;top:12px;color:#fff;font-family:Inter,Arial,sans-serif}
  #ui .stat{background:rgba(0,0,0,0.4);padding:8px;border-radius:6px;margin-bottom:8px}
  #hint{position:absolute;left:12px;bottom:12px;color:#fff;background:rgba(0,0,0,0.4);padding:8px;border-radius:6px}
  #minimap{position:absolute;right:12px;top:12px;border:2px solid rgba(0,0,0,0.5);background:#222;border-radius:6px;padding:6px}
  #minimap canvas{display:block;background:#333}
  button{padding:6px 10px;border-radius:6px;border:none;background:#28a745;color:white;cursor:pointer}
</style>
</head>
<body>
<div id="ui">
  <div class="stat">Mode: <span id="mode">OnFoot</span></div>
  <div class="stat">Speed: <span id="speed">0</span></div>
  <div class="stat">Money: $<span id="money">0</span></div>
  <div><button id="spawnCar">Spawn Car</button> <button id="toggleCamera">Toggle Cam</button></div>
</div>
<div id="minimap"><canvas id="map" width="160" height="160"></canvas></div>
<div id="hint">WASD / Arrow keys — move, E — enter/exit car, Space — handbrake, M — mission</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/controls/PointerLockControls.js"></script>

<script>
// --- Settings
const WORLD_SIZE = 400;
const PLAYER_SPEED = 4;
const CAR_SPEED = 10;
const CAR_TURN = 0.04;

// --- Scene + Renderer
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x87ceeb, 0.0006);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x87ceeb);
document.body.appendChild(renderer.domElement);

// --- Camera system
const camThird = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
const camMinimap = new THREE.PerspectiveCamera(75,1,0.1,2000);
let camera = camThird;
let camMode = 'follow'; // follow or top

// --- Lights
const amb = new THREE.AmbientLight(0xffffff, 0.6); scene.add(amb);
const sun = new THREE.DirectionalLight(0xfff7e6, 0.8); sun.position.set(100,200,100); scene.add(sun);

// --- Ground (grid + blocks to look roblox-y)
const groundGeo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, 1,1);
const groundMat = new THREE.MeshPhongMaterial({color:0x4caf50});
const ground = new THREE.Mesh(groundGeo, groundMat); ground.rotation.x = -Math.PI/2; scene.add(ground);

// Create simple "city" blocks (low poly / blocky like Roblox)
const blockMat = new THREE.MeshPhongMaterial({color:0x8d6e63});
for(let i=-3;i<=3;i++){
  for(let j=-3;j<=3;j++){
    if(Math.random() < 0.6){
      const h = 6 + Math.floor(Math.random()*18);
      const box = new THREE.Mesh(new THREE.BoxGeometry(20, h, 20), blockMat);
      box.position.set(i*40 + (Math.random()*10-5), h/2, j*40 + (Math.random()*10-5));
      scene.add(box);
      box.userData.block = true;
    }
  }
}

// Simple roads: lower green -> gray strips
const roadMat = new THREE.MeshPhongMaterial({color:0x333333});
for(let r=-2;r<=2;r++){
  const strip = new THREE.Mesh(new THREE.BoxGeometry(WORLD_SIZE, 0.1, 8), roadMat);
  strip.position.set(0,0.05,r*40); scene.add(strip);
}
for(let c=-2;c<=2;c++){
  const strip = new THREE.Mesh(new THREE.BoxGeometry(8, 0.1, WORLD_SIZE), roadMat);
  strip.position.set(c*40,0.05,0); scene.add(strip);
}

// --- Player (blocky Roblox aesthetic)
const player = new THREE.Mesh(new THREE.BoxGeometry(2,4,2), new THREE.MeshPhongMaterial({color:0x2196f3}));
player.position.set(0,2,30);
player.userData.velocity = new THREE.Vector3();
scene.add(player);

// --- Simple car (spawnable)
let car = null;
function spawnCar(x=5,z=25){
  if(car){ scene.remove(car.root); car = null; }
  const root = new THREE.Object3D();
  const body = new THREE.Mesh(new THREE.BoxGeometry(6,2.2,4), new THREE.MeshPhongMaterial({color:0xff5722}));
  body.position.set(0,1.2,0); root.add(body);
  // wheels (visual only)
  const wheelMat = new THREE.MeshPhongMaterial({color:0x111});
  for(let wx of [-2.2,2.2]){
    for(let wz of [-1.6,1.6]){
      const w = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.8,1), wheelMat);
      w.position.set(wx,0.4,wz); root.add(w);
    }
  }
  root.position.set(x,0.1,z);
  scene.add(root);
  car = {
    root, body, speed:0, steer:0, seats:1, driver:null
  };
  return car;
}

// --- Simple collision detection with buildings (AABB)
function aabbIntersect(objA, objB){
  const a = new THREE.Box3().setFromObject(objA);
  const b = new THREE.Box3().setFromObject(objB);
  return a.intersectsBox(b);
}
function preventPenetration(mover){
  // iterate blocks and push out
  scene.traverse(o=>{
    if(o.userData.block){
      const a = new THREE.Box3().setFromObject(mover);
      const b = new THREE.Box3().setFromObject(o);
      if(a.intersectsBox(b)){
        // simple response: move mover back along its velocity
        mover.position.sub(mover.userData.velocity.clone().setY(0).multiplyScalar(0.2));
        mover.userData.velocity.multiplyScalar(0.2);
      }
    }
  });
}

// --- Controls
const keys = {};
window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()]=true; if(e.key==='Escape') document.exitPointerLock();});
window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()]=false; });

const pointerControls = new THREE.PointerLockControls(camThird, renderer.domElement);
renderer.domElement.addEventListener('click', ()=>{ pointerControls.lock(); });

document.getElementById('spawnCar').addEventListener('click', ()=>{ spawnCar(player.position.x+6, player.position.z); });
document.getElementById('toggleCamera').addEventListener('click', ()=>{ camMode = camMode==='follow' ? 'top' : 'follow'; });

// --- Missions simple
let money = 0;
document.addEventListener('keypress', (e)=>{
  if(e.key.toLowerCase()==='m'){
    // spawn a "delivery" marker
    createMarker(new THREE.Vector3((Math.random()-0.5)*200, 0, (Math.random()-0.5)*200));
  }
  if(e.key.toLowerCase()==='e'){ // enter/exit car
    if(car && car.root && car.driver === null){
      // check distance
      if(car.root.position.distanceTo(player.position) < 6){
        car.driver = player;
        player.visible = false;
        document.getElementById('mode').textContent = 'InCar';
      }
    } else if(car && car.driver === player){
      car.driver = null;
      player.visible = true;
      player.position.copy(car.root.position).add(new THREE.Vector3(4,0,0));
      document.getElementById('mode').textContent = 'OnFoot';
    }
  }
});

// --- Markers (missions)
const markers = [];
function createMarker(pos){
  const geo = new THREE.CylinderGeometry(0.8,0.8,0.2,6);
  const mat = new THREE.MeshBasicMaterial({color:0xffff00});
  const m = new THREE.Mesh(geo, mat);
  m.position.copy(pos).add(new THREE.Vector3(0,0.1,0));
  scene.add(m);
  markers.push(m);
}

// --- Minimap draw
const mapCanvas = document.getElementById('map');
const mapCtx = mapCanvas.getContext('2d');
function drawMinimap(){
  mapCtx.clearRect(0,0,mapCanvas.width,mapCanvas.height);
  // background
  mapCtx.fillStyle = '#2b7a2b'; mapCtx.fillRect(0,0,160,160);
  // roads
  mapCtx.fillStyle='#222';
  // horizontal
  for(let r=-2;r<=2;r++){
    const y = mapCanvas.height/2 + r*20;
    mapCtx.fillRect(0,y-4,160,8);
  }
  // vertical
  for(let c=-2;c<=2;c++){
    const x = mapCanvas.width/2 + c*20;
    mapCtx.fillRect(x-4,0,8,160);
  }
  // player marker
  const scale = 0.4;
  const px = mapCanvas.width/2 + player.position.x*scale;
  const py = mapCanvas.height/2 + player.position.z*scale;
  mapCtx.fillStyle='#2196f3'; mapCtx.beginPath(); mapCtx.arc(px,py,5,0,Math.PI*2); mapCtx.fill();
  // car marker
  if(car){
    const cx = mapCanvas.width/2 + car.root.position.x*scale;
    const cy = mapCanvas.height/2 + car.root.position.z*scale;
    mapCtx.fillStyle='#ff5722'; mapCtx.beginPath(); mapCtx.arc(cx,cy,5,0,Math.PI*2); mapCtx.fill();
  }
  // markers
  for(const m of markers){
    const mx = mapCanvas.width/2 + m.position.x*scale;
    const my = mapCanvas.height/2 + m.position.z*scale;
    mapCtx.fillStyle='#ffff00'; mapCtx.fillRect(mx-4,my-4,8,8);
  }
}

// --- Simple physics + update loop
const clock = new THREE.Clock();
function update(){
  const dt = Math.min(0.05, clock.getDelta());
  // Movement input
  let forward = keys['w'] || keys['arrowup'];
  let back = keys['s'] || keys['arrowdown'];
  let left = keys['a'] || keys['arrowleft'];
  let right = keys['d'] || keys['arrowright'];
  // If in car: drive
  if(car && car.driver === player){
    // accelerate/brake
    if(forward) car.speed = Math.min(40, car.speed + CAR_SPEED * dt);
    else if(back) car.speed = Math.max(-10, car.speed - CAR_SPEED * dt);
    else car.speed = car.speed * 0.98;
    // steering
    if(left) car.steer = Math.max(-0.5, car.steer - CAR_TURN);
    else if(right) car.steer = Math.min(0.5, car.steer + CAR_TURN);
    else car.steer *= 0.9;
    // update position
    const dir = new THREE.Vector3(Math.sin(car.root.rotation.y),0,Math.cos(car.root.rotation.y));
    car.root.rotation.y += car.steer * car.speed * 0.0007 * (1+Math.abs(car.speed)/10);
    car.root.position.add(dir.multiplyScalar(car.speed * 0.02 * dt*60));
    // simple friction
    car.speed *= 0.995;
    // collision simple
    preventPenetration(car.root);
    // camera attach
    if(camMode === 'follow'){
      const offset = new THREE.Vector3(0,6,-12).applyAxisAngle(new THREE.Vector3(0,1,0), car.root.rotation.y);
      camThird.position.copy(car.root.position).add(offset);
      camThird.lookAt(car.root.position.clone().add(new THREE.Vector3(0,2,0)));
    } else {
      camThird.position.set(car.root.position.x, 120, car.root.position.z+0.1);
      camThird.lookAt(car.root.position);
    }
    document.getElementById('mode').textContent = 'InCar';
    document.getElementById('speed').textContent = Math.round(car.speed);
  } else {
    // on foot physics
    let move = new THREE.Vector3();
    if(forward) move.z -= 1;
    if(back) move.z += 1;
    if(left) move.x -= 1;
    if(right) move.x += 1;
    if(move.length()>0) move.normalize().multiplyScalar(PLAYER_SPEED * dt * 60);
    // rotate player toward camera forward
    if(pointerControls.isLocked){
      // use pointer yaw to orient
      const euler = new THREE.Euler(0, pointerControls.getObject().rotation.y, 0, 'YXZ');
      player.rotation.y = euler.y;
    }
    // apply in world coords (camera relative)
    const worldMove = move.clone().applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
    player.userData.velocity.lerp(worldMove, 0.6);
    player.position.add(player.userData.velocity);
    // keep above ground
    player.position.y = 2;
    preventPenetration(player);
    // attach camera behind player
    if(camMode === 'follow'){
      const backOffset = new THREE.Vector3(0,6,-10).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
      camThird.position.copy(player.position).add(backOffset);
      camThird.lookAt(player.position.clone().add(new THREE.Vector3(0,2,0)));
    } else {
      camThird.position.set(player.position.x, 120, player.position.z+0.1);
      camThird.lookAt(player.position);
    }
    document.getElementById('mode').textContent = 'OnFoot';
    document.getElementById('speed').textContent = Math.round(player.userData.velocity.length()*10);
  }

  // markers interactions
  for(let i=markers.length-1;i>=0;i--){
    const m = markers[i];
    if((car && car.root.position.distanceTo(m.position) < 6) || player.position.distanceTo(m.position) < 4){
      // complete mission
      scene.remove(m); markers.splice(i,1);
      money += 100; document.getElementById('money').textContent = money;
      // visual reward: spawn coins (simple)
      const coin = new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.3,0.1,6), new THREE.MeshBasicMaterial({color:0xffd700}));
      coin.position.copy((car && car.root.position.distanceTo(m.position) < 6) ? car.root.position.clone() : player.position.clone()).add(new THREE.Vector3(0,3,0));
      scene.add(coin);
      setTimeout(()=>{ scene.remove(coin); }, 1500);
    }
  }

  // simple ground bounds
  if(player.position.x > WORLD_SIZE/2) player.position.x = WORLD_SIZE/2;
  if(player.position.x < -WORLD_SIZE/2) player.position.x = -WORLD_SIZE/2;
  if(player.position.z > WORLD_SIZE/2) player.position.z = WORLD_SIZE/2;
  if(player.position.z < -WORLD_SIZE/2) player.position.z = -WORLD_SIZE/2;
  if(car){
    if(car.root.position.x > WORLD_SIZE/2) car.root.position.x = WORLD_SIZE/2;
    if(car.root.position.x < -WORLD_SIZE/2) car.root.position.x = -WORLD_SIZE/2;
    if(car.root.position.z > WORLD_SIZE/2) car.root.position.z = WORLD_SIZE/2;
    if(car.root.position.z < -WORLD_SIZE/2) car.root.position.z = -WORLD_SIZE/2;
  }

  // update minimap
  drawMinimap();

  renderer.render(scene, camThird);
  requestAnimationFrame(update);
}

// initialize velocities
player.userData.velocity = new THREE.Vector3();

// initial spawn car
spawnCar(8,26);

// resize handler
window.addEventListener('resize', ()=>{ camThird.aspect = window.innerWidth / window.innerHeight; camThird.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

// start loop
update();
</script>
</body>
</html>
