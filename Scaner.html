<!DOCTYPE html>
<html lang="ru">
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mini True Skate Road</title>
<style>
  body, html {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #111;
    touch-action: none;
  }
  canvas {
    display: block;
    background: #111;
  }
</style>
</head>
<body>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

// ----------------------
// ПАРАМЕТРЫ СКЕЙТА
// ----------------------
let board = {
  x: canvas.width / 2,
  y: canvas.height * 0.7,
  vx: 0,
  vy: 0,
  angle: 0,
  width: 160,
  height: 40
};

let friction = 0.96;

// ----------------------
// ДЛЯ ЭФФЕКТА ДОРОГИ
// ----------------------
let roadOffset = 0;
let roadSpeed = 0;

// ----------------------
// СВАЙП-УПРАВЛЕНИЕ
// ----------------------
let touchStart = null;

canvas.addEventListener("touchstart", e => {
  const t = e.touches[0];
  touchStart = { x: t.clientX, y: t.clientY };
});

canvas.addEventListener("touchend", e => {
  if (!touchStart) return;

  const t = e.changedTouches[0];
  const dx = t.clientX - touchStart.x;
  const dy = t.clientY - touchStart.y;

  // сила свайпа
  board.vx += dx * 0.05;
  board.vy += dy * 0.02;

  // скорость дороги по вертикали (ощущение движения вперёд)
  roadSpeed = -dy * 0.05;

  touchStart = null;
});

// ----------------------
// ОБНОВЛЕНИЕ ФИЗИКИ
// ----------------------
function update() {
  board.x += board.vx;
  board.y += board.vy;

  board.vx *= friction;
  board.vy *= friction;

  // скейт всегда примерно в нижней части экрана
  board.y = canvas.height * 0.7;

  // границы по X
  const margin = 40;
  if (board.x < margin) board.x = margin;
  if (board.x > canvas.width - margin) board.x = canvas.width - margin;

  // обновление дороги
  roadOffset += roadSpeed;
  roadSpeed *= 0.95;
}

// ----------------------
// ОТРИСОВКА ДОРОГИ
// ----------------------
function drawRoad() {
  const w = canvas.width;
  const h = canvas.height;

  // фон
  ctx.fillStyle = "#111";
  ctx.fillRect(0, 0, w, h);

  // дорога — трапеция для перспективы
  const roadTopWidth = w * 0.3;
  const roadBottomWidth = w * 0.8;
  const roadTopY = h * 0.1;
  const roadBottomY = h;

  const roadTopLeft = (w - roadTopWidth) / 2;
  const roadBottomLeft = (w - roadBottomWidth) / 2;

  // асфальт
  ctx.beginPath();
  ctx.moveTo(roadTopLeft, roadTopY);
  ctx.lineTo(roadTopLeft + roadTopWidth, roadTopY);
  ctx.lineTo(roadBottomLeft + roadBottomWidth, roadBottomY);
  ctx.lineTo(roadBottomLeft, roadBottomY);
  ctx.closePath();

  const roadGradient = ctx.createLinearGradient(0, roadTopY, 0, roadBottomY);
  roadGradient.addColorStop(0, "#303030");
  roadGradient.addColorStop(1, "#202020");
  ctx.fillStyle = roadGradient;
  ctx.fill();

  // разметка (полоски по центру)
  ctx.strokeStyle = "#f5f5f5";
  ctx.lineWidth = 4;

  const segments = 10;
  for (let i = -1; i < segments + 1; i++) {
    const t1 = i / segments;
    const t2 = (i + 0.5) / segments;

    const y1 = roadTopY + (roadBottomY - roadTopY) * t1 + (roadOffset % (h / segments));
    const y2 = roadTopY + (roadBottomY - roadTopY) * t2 + (roadOffset % (h / segments));

    const centerX1 = w / 2;
    const centerX2 = w / 2;

    if (y2 < roadTopY || y1 > roadBottomY) continue;

    ctx.beginPath();
    ctx.moveTo(centerX1, y1);
    ctx.lineTo(centerX2, y2);
    ctx.stroke();
  }
}

// ----------------------
// ОТРИСОВКА СКЕЙТА
// ----------------------
function drawBoard() {
  ctx.save();
  ctx.translate(board.x, board.y);
  ctx.rotate(board.angle);

  // тень под скейтом
  ctx.fillStyle = "rgba(0,0,0,0.4)";
  ctx.beginPath();
  ctx.ellipse(0, 18, board.width * 0.5, 10, 0, 0, Math.PI * 2);
  ctx.fill();

  // деки (форма скейта с закруглёнными концами)
  const r = board.height / 2;
  const len = board.width - board.height;

  ctx.fillStyle = "#f5a623";
  ctx.beginPath();
  ctx.moveTo(-len/2, -r);
  ctx.lineTo(len/2, -r);
  ctx.arc(len/2, 0, r, -Math.PI/2, Math.PI/2);
  ctx.lineTo(-len/2, r);
  ctx.arc(-len/2, 0, r, Math.PI/2, -Math.PI/2);
  ctx.closePath();
  ctx.fill();

  // контур деки
  ctx.strokeStyle = "#b36b00";
  ctx.lineWidth = 3;
  ctx.stroke();

  // верхняя графика
  ctx.strokeStyle = "#ffffff";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-len/2 + 10, 0);
  ctx.lineTo(len/2 - 10, 0);
  ctx.stroke();

  // траки и колёса
  const truckOffsetX = board.width * 0.25;
  const truckY = 8;
  const wheelRadius = 7;

  function drawTruck(x) {
    // ось
    ctx.strokeStyle = "#444";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x - 14, truckY);
    ctx.lineTo(x + 14, truckY);
    ctx.stroke();

    // колёса
    ctx.fillStyle = "#111";
    ctx.beginPath();
    ctx.arc(x - 16, truckY + 4, wheelRadius, 0, Math.PI * 2);
    ctx.arc(x + 16, truckY + 4, wheelRadius, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "#666";
    ctx.beginPath();
    ctx.arc(x - 16, truckY + 4, 3, 0, Math.PI * 2);
    ctx.arc(x + 16, truckY + 4, 3, 0, Math.PI * 2);
    ctx.fill();
  }

  drawTruck(-truckOffsetX);
  drawTruck(truckOffsetX);

  ctx.restore();
}

// ----------------------
// ГЛАВНЫЙ ЦИКЛ
// ----------------------
function loop() {
  update();
  drawRoad();
  drawBoard();
  requestAnimationFrame(loop);
}
loop();
</script>

</body>
</html>
