<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
<title>Monkey Quest — улучшенные бананы</title>
<style>
  :root{--bg1:#f7fbff;--bg2:#eaf3fb;--panel:#ffffff;--accent:#ffd77a;--dark:#07323a}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),var(--bg2));font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;-webkit-text-size-adjust:100%}
  #wrap{display:flex;flex-direction:column;height:100vh;overflow:hidden}
  header{padding:10px 12px;display:flex;align-items:center;justify-content:space-between;background:linear-gradient(180deg,var(--panel),#f1f5f9);box-shadow:0 6px 18px rgba(13,40,58,0.06);z-index:20}
  h1{font-size:16px;margin:0;color:var(--dark)}
  #hud{display:flex;gap:10px;align-items:center}
  .pill{background:linear-gradient(180deg,var(--panel),#f7fafc);padding:6px 10px;border-radius:12px;font-weight:700;border:1px solid rgba(7,34,51,0.06);color:var(--dark)}
  main{flex:1;position:relative;min-height:0}
  canvas#c{position:absolute;left:0;top:0;width:100vw;height:calc(100vh - 56px);display:block;z-index:0}
  .ui-layer{position:absolute;left:0;top:0;width:100%;height:100%;z-index:30;pointer-events:none}
  #overlay{position:fixed;left:12px;bottom:12px;display:flex;gap:12px;align-items:end;pointer-events:none;z-index:35}
  .joy{width:110px;height:110px;border-radius:999px;background:rgba(7,34,51,0.05);display:flex;align-items:center;justify-content:center;pointer-events:auto;touch-action:none;border:1px solid rgba(7,34,51,0.06)}
  .thumb{width:48px;height:48px;border-radius:999px;background:linear-gradient(180deg,var(--accent),#ffc857);transform:translate(0,0)}
  .jump-circle{position:fixed;right:12px;bottom:12px;width:110px;height:110px;border-radius:999px;background:rgba(255,255,255,0.18);display:flex;align-items:center;justify-content:center;pointer-events:auto;border:1px solid rgba(7,34,51,0.06);z-index:35}
  .jump-arrow{width:0;height:0;border-left:14px solid transparent;border-right:14px solid transparent;border-bottom:22px solid var(--dark);transform:translateY(-3px)}
  #restartSmall{position:fixed;left:12px;top:12px;pointer-events:auto;width:44px;height:44px;border-radius:8px;background:linear-gradient(180deg,var(--panel),#f7fafc);display:flex;align-items:center;justify-content:center;border:1px solid rgba(7,34,51,0.06);box-shadow:0 4px 10px rgba(13,40,58,0.04);z-index:35}
  #hint{position:fixed;left:12px;top:64px;background:rgba(255,255,255,0.95);padding:8px;border-radius:8px;font-size:13px;border:1px solid rgba(7,34,51,0.04);z-index:35;pointer-events:auto}
  footer{padding:8px 12px;font-size:12px;color:#3b5566;background:linear-gradient(180deg,transparent,#f1f5f9);z-index:20}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <h1>Monkey Quest</h1>
    <div id="hud">
      <div class="pill">Очки: <span id="score">0</span></div>
      <div class="pill">Время: <span id="time">60</span>s</div>
      <div class="pill">Уровень: <span id="level">1</span></div>
    </div>
  </header>

  <main>
    <canvas id="c" role="img" aria-label="Игровое поле"></canvas>

    <div class="ui-layer" aria-hidden="false">
      <div id="overlay">
        <div class="joy" id="joy" aria-hidden="true">
          <div class="thumb" id="thumb"></div>
        </div>
      </div>

      <div id="restartSmall" title="Рестарт" aria-label="Рестарт">
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M21 12a9 9 0 1 0-2.64 6.09" stroke="#07323a" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M21 4v6h-6" stroke="#07323a" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>

      <div id="hint">Бананы: улучшенная модель, покачивание и партиклы при сборе</div>

      <div class="jump-circle" id="jumpBtn" aria-label="Прыжок" title="Прыжок">
        <div class="jump-arrow" aria-hidden="true"></div>
      </div>
    </div>
  </main>

  <footer>Открой на телефоне в Safari/Chrome. Левая рука — джойстик, правая — поворот.</footer>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
/* Улучшённые бананы для мобильной игры
   - LatheGeometry для формы
   - CanvasTexture для легкой текстуры/шероховатости
   - покачивание, вращение
   - партиклы при сборе
*/

(function(){
  // быстрые проверки
  function webglAvailable(){ try { const c=document.createElement('canvas'); return !!(window.WebGLRenderingContext && (c.getContext('webgl') || c.getContext('experimental-webgl'))); } catch(e){ return false; } }
  if(!webglAvailable()){ document.body.innerHTML = '<p style="padding:20px;font-family:Arial">WebGL не поддерживается в этом браузере.</p>'; return; }

  // DOM
  const canvas = document.getElementById('c');
  const scoreEl = document.getElementById('score');
  const timeEl = document.getElementById('time');
  const levelEl = document.getElementById('level');
  const joy = document.getElementById('joy');
  const thumb = document.getElementById('thumb');
  const jumpBtn = document.getElementById('jumpBtn');
  const restartSmall = document.getElementById('restartSmall');

  // three
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  renderer.setClearColor(0xeaf3fb);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60,1,0.1,200);
  camera.position.set(0,8,12);

  // lights
  const key = new THREE.DirectionalLight(0xffffff,0.9); key.position.set(5,12,6); key.castShadow=true; scene.add(key);
  const fill = new THREE.HemisphereLight(0xddeeff,0x404060,0.55); scene.add(fill);

  // ground
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(80,80), new THREE.MeshStandardMaterial({color:0xe6eef4, roughness:0.95}));
  ground.rotation.x = -Math.PI/2; ground.receiveShadow=true; scene.add(ground);

  // simple monkey placeholder (keeps scene consistent)
  const monkey = new THREE.Group();
  const body = new THREE.Mesh(new THREE.SphereGeometry(0.7,20,16), new THREE.MeshStandardMaterial({color:0x9c6b3a}));
  body.position.y = 0.75; monkey.add(body);
  scene.add(monkey);

  // banana factory: Lathe geometry along slice curve
  function makeBananaGeometry(length = 0.9, segments = 18, thickness = 0.18){
    // profile of half banana cross-section (simple curve)
    const pts = [];
    const half = thickness;
    // build a curved profile (from inner curve to outer)
    for(let i=0;i<=segments;i++){
      const t = i/segments;
      // radius tapers towards tips
      const radius = half * (1 - 0.5*Math.abs(2*t-1)) * (0.8 + 0.4*Math.sin(t*Math.PI));
      const x = (t - 0.5) * length; // along axis
      const y = radius;
      pts.push(new THREE.Vector2(y, x));
    }
    // Lathe expects points in XY plane (here we use Vector2(r, z))
    const lathe = new THREE.LatheGeometry(pts, Math.max(8, Math.round(32 * (thickness/0.18))), 0, Math.PI*2);
    // Slightly stretch ends to get banana tapering
    // (we'll not modify vertices for simplicity — acceptable polycount)
    return lathe;
  }

  // banana material: CanvasTexture for subtle gradient and spots
  function makeBananaMaterial(){
    const size = 128;
    const c = document.createElement('canvas'); c.width = c.height = size;
    const ctx = c.getContext('2d');
    // background gradient
    const g = ctx.createLinearGradient(0,0,size, size);
    g.addColorStop(0, '#fff3c6');
    g.addColorStop(0.5, '#ffd85a');
    g.addColorStop(1, '#ffdf7a');
    ctx.fillStyle = g; ctx.fillRect(0,0,size,size);
    // small brown speckles
    ctx.fillStyle = 'rgba(85,42,12,0.18)';
    for(let i=0;i<40;i++){
      const x = Math.random()*size, y = Math.random()*size;
      ctx.beginPath(); ctx.arc(x,y, Math.random()*2.5, 0, Math.PI*2); ctx.fill();
    }
    // dark tip gradient (draw near edge)
    const tg = ctx.createLinearGradient(size*0.8, 0, size, size);
    tg.addColorStop(0, 'rgba(0,0,0,0.0)'); tg.addColorStop(1, 'rgba(90,40,8,0.28)');
    ctx.fillStyle = tg; ctx.fillRect(size*0.6,0,size*0.4,size);

    const tex = new THREE.CanvasTexture(c);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(1,1);

    const mat = new THREE.MeshStandardMaterial({
      map: tex,
      color: 0xffffff,
      metalness: 0.05,
      roughness: 0.45,
      emissive: 0x0b0b00,
      emissiveIntensity: 0.02
    });
    return mat;
  }

  // create a banana mesh (with pivot aligned to bottom for nicer animation)
  function createBanana(){
    const geo = makeBananaGeometry(0.9, 16, 0.18);
    // rotate so long axis aligns with X (we used (r,x) ordering)
    geo.rotateZ(Math.PI/2);
    // create two materials: main + dark tip overlay
    const mat = makeBananaMaterial();
    const mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = true; mesh.receiveShadow = true;

    // add small dark cap at one end (tip)
    const capGeo = new THREE.SphereGeometry(0.06, 8, 8);
    const capMat = new THREE.MeshStandardMaterial({color:0x5b3a19});
    const cap = new THREE.Mesh(capGeo, capMat);
    cap.position.set(-0.47, 0, 0.02); // place near one tip (tweak if needed)
    mesh.add(cap);

    // create inner pivot object so we can animate rotation/pitch easily
    const pivot = new THREE.Object3D();
    pivot.add(mesh);
    // center mesh to pivot (slight offset)
    mesh.position.set(0, 0, 0);
    return {pivot, mesh, cap};
  }

  // banana instances container
  const bananas = [];

  // spawn N bananas scattered around (avoids monkey area)
  function spawnBananas(n=10){
    // remove existing
    bananas.forEach(b=>scene.remove(b.pivot));
    bananas.length = 0;
    for(let i=0;i<n;i++){
      const b = createBanana();
      // random position
      const x = (Math.random()-0.5)*22;
      const z = (Math.random()-0.5)*22;
      b.pivot.position.set(x, 0.12 + Math.random()*0.18, z);
      // random orientation and gentle tilt
      b.pivot.rotation.y = Math.random()*Math.PI*2;
      b.mesh.rotation.x = (Math.random()-0.5)*0.35;
      scene.add(b.pivot);
      b._floatOffset = Math.random()*1000;
      b._collected = false;
      bananas.push(b);
    }
  }

  // particle effects container (simple sprite circles)
  const particles = [];
  function spawnCollectParticles(posWorld, color='#ffd75a', count=12){
    for(let i=0;i<count;i++){
      const size = 0.06 + Math.random()*0.08;
      const canvas = document.createElement('canvas'); canvas.width = canvas.height = 64;
      const ctx = canvas.getContext('2d');
      ctx.beginPath(); ctx.fillStyle = color; ctx.globalAlpha = 0.95; ctx.arc(32,32,28,0,Math.PI*2); ctx.fill();
      const tex = new THREE.CanvasTexture(canvas);
      const mat = new THREE.SpriteMaterial({map: tex, transparent:true, depthWrite:false});
      const sp = new THREE.Sprite(mat);
      sp.scale.set(size, size, size);
      sp.position.copy(posWorld);
      // give initial velocity
      sp.userData = {
        vel: new THREE.Vector3((Math.random()-0.5)*1.4, 0.6 + Math.random()*1.2, (Math.random()-0.5)*1.4),
        life: 0.6 + Math.random()*0.6
      };
      scene.add(sp); particles.push(sp);
    }
  }

  // game state + simple physics for particles & banana animation
  function animateBananas(dt){
    const time = performance.now()*0.001;
    for(let i=bananas.length-1;i>=0;i--){
      const b = bananas[i];
      if(b._collected) continue;
      // gentle bobbing and subtle rotation
      const bob = Math.sin(time*1.2 + b._floatOffset)*0.06;
      b.pivot.position.y = 0.12 + bob;
      b.pivot.rotation.z = Math.sin(time*0.6 + b._floatOffset)*0.06;
      // spin slowly
      b.pivot.rotation.y += 0.001 * (1 + (i%3));

      // simple check: if near monkey (we'll use monkey at origin in demo), collect
      const dx = b.pivot.position.x - monkey.position.x;
      const dz = b.pivot.position.z - monkey.position.z;
      const dist = Math.hypot(dx, dz);
      if(dist < 1.0){
        // collect banana
        b._collected = true;
        // animate scale up + pop
        const popDuration = 220;
        const start = performance.now();
        const startPos = b.pivot.position.clone();
        // spawn particles
        spawnCollectParticles(startPos, '#ffd85a', 10);
        // add score
        score += 10; scoreEl.textContent = score;
        // remove after animation
        (function localRemove(){
          const now = performance.now();
          const t = (now - start)/popDuration;
          if(t < 1){
            const s = 1 + Math.sin(t*Math.PI)*0.6;
            b.pivot.scale.setScalar(s);
            b.pivot.position.y = startPos.y + t*0.6;
            requestAnimationFrame(localRemove);
          } else {
            scene.remove(b.pivot);
            bananas.splice(i,1);
          }
        })();
      }
    }

    // animate particles
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      const ud = p.userData;
      ud.life -= dt;
      if(ud.life <= 0){
        scene.remove(p); particles.splice(i,1);
        continue;
      }
      // simple physics
      ud.vel.y -= 2.2 * dt; // gravity
      p.position.addScaledVector(ud.vel, dt);
      // fade
      p.material.opacity = Math.max(0, ud.life / 1.0);
      // shrink slightly
      const scale = Math.max(0.01, p.scale.x * (0.98 - dt*0.1));
      p.scale.setScalar(scale);
    }
  }

  // spawn initial batch
  spawnBananas(12);

  // simple monkey placeholder position (for demo movement use joystick code later)
  monkey.position.set(0,0.02,0);

  // resize handler
  function resize(){
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    renderer.setPixelRatio(dpr);
    const w = window.innerWidth;
    const h = window.innerHeight - document.querySelector('header').offsetHeight;
    renderer.setSize(w, h, false);
    camera.aspect = w / h; camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', resize);
  resize();

  // minimal joystick & controls to move monkey for demo
  let joyTouchId = null, joyCenter = {x:0,y:0}, joyRadius = 42;
  let move = {x:0,y:0};
  function updateJoy(cx,cy){
    const dx = cx - joyCenter.x, dy = cy - joyCenter.y;
    const dist = Math.hypot(dx,dy);
    const nx = dx/(dist||1), ny = dy/(dist||1);
    const mag = Math.min(dist/joyRadius,1);
    move.x = nx * mag;
    move.y = -ny * mag; // forward is up on joystick
    thumb.style.transform = `translate(${move.x*(joyRadius-18)}px, ${-move.y*(joyRadius-18)}px)`;
  }
  function endJoy(){ joyTouchId = null; move.x=move.y=0; thumb.style.transform='translate(0,0)'; }
  // simple multitouch binding for demo: left area joystick
  window.addEventListener('touchstart', (e)=>{
    for(const t of e.changedTouches){
      const W = window.innerWidth;
      if(t.clientX < W*0.45 && joyTouchId === null){
        joyTouchId = t.identifier;
        const rect = joy.getBoundingClientRect();
        joyCenter = {x: rect.left+rect.width/2, y: rect.top+rect.height/2};
        joyRadius = Math.min(rect.width, rect.height)/2 - 6;
        updateJoy(t.clientX, t.clientY);
        e.preventDefault();
      }
    }
  }, {passive:false});
  window.addEventListener('touchmove', (e)=>{
    if(joyTouchId !== null){
      for(const t of e.touches){
        if(t.identifier === joyTouchId){ updateJoy(t.clientX, t.clientY); break; }
      }
    }
  }, {passive:false});
  window.addEventListener('touchend', (e)=>{ for(const t of e.changedTouches) if(t.identifier === joyTouchId) endJoy(); }, {passive:true});
  window.addEventListener('touchcancel', (e)=>{ for(const t of e.changedTouches) if(t.identifier === joyTouchId) endJoy(); }, {passive:true});

  // jump button minimalist
  jumpBtn.addEventListener('touchstart', (e)=>{ e.preventDefault(); /* small hop */ monkey.position.y += 0.18; setTimeout(()=>monkey.position.y = 0.02, 220); }, {passive:false});

  // restart
  restartSmall.addEventListener('touchstart', (e)=>{ e.preventDefault(); spawnBananas(12); score = 0; scoreEl.textContent = score; }, {passive:false});

  // animation loop (movement + bananas + particles)
  let last = performance.now();
  function loop(now){
    const dt = Math.min((now - last)/1000, 0.05); last = now;
    // simple movement: move in XZ plane relative to camera forward
    if(Math.abs(move.x) > 0.01 || Math.abs(move.y) > 0.01){
      const speed = 3.5;
      // camera-forward substitute: move along world axes for demo
      monkey.position.x += move.x * speed * dt;
      monkey.position.z += move.y * speed * dt;
    }
    animateBananas(dt);
    // camera follow monkey
    camera.position.lerp(new THREE.Vector3(monkey.position.x, monkey.position.y + 4.0, monkey.position.z + 9.0), 0.12);
    camera.lookAt(monkey.position.x, monkey.position.y + 1.2, monkey.position.z);
    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // expose spawn for debug in console
  window._spawnBananas = spawnBananas;
})();
</script>
</body>
</html>
